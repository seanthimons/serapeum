---
phase: 22-module-migration
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - R/mod_document_notebook.R
autonomous: true

must_haves:
  truths:
    - "User opens notebook with documents but no per-notebook store and sees a migration prompt to re-index"
    - "User declines re-index and RAG controls (chat send button) are greyed out with tooltip"
    - "User accepts re-index and sees progress modal with per-document detail (e.g. 'Embedding 3 of 12: Smith et al. 2023')"
    - "User can cancel re-index mid-way via Stop button; partial store is deleted and rag_ready set to FALSE"
    - "PDF upload writes to per-notebook ragnar store, not shared store"
    - "Empty notebook (no documents) does NOT show migration prompt"
  artifacts:
    - path: "R/mod_document_notebook.R"
      provides: "Migration prompt, rag_ready state, per-notebook store wiring in upload handler"
      contains: "rag_ready"
  key_links:
    - from: "R/mod_document_notebook.R"
      to: "R/_ragnar.R"
      via: "ensure_ragnar_store, get_notebook_ragnar_path, rebuild_notebook_store, delete_notebook_store"
      pattern: "ensure_ragnar_store|get_notebook_ragnar_path"
---

<objective>
Migrate document notebook module to use per-notebook ragnar stores: add migration detection and re-index prompt, rag_ready state for greyed-out controls, rewire PDF upload to use per-notebook store.

Purpose: Document notebooks achieve true per-notebook isolation. Existing notebooks with content but no store prompt users to re-index. RAG features disabled until store exists.

Output: Updated mod_document_notebook.R with full per-notebook store wiring.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/22-module-migration/22-RESEARCH.md
@.planning/phases/22-module-migration/22-01-SUMMARY.md
@.planning/phases/21-store-lifecycle/21-02-SUMMARY.md

Key references:
- R/mod_document_notebook.R lines 122-200: Existing Phase 21 store_healthy reactiveVal, integrity check, rebuild handler
- R/mod_document_notebook.R lines 315-384: PDF upload embedding block (currently uses shared store path)
- R/mod_document_notebook.R line 522: rag_query() call (already passes notebook_id to search_chunks_hybrid via rag.R)
- R/mod_document_notebook.R lines 325-344: ragnar store path construction using config → needs replacement
- R/_ragnar.R: ensure_ragnar_store(), rebuild_notebook_store(), delete_notebook_store(), get_notebook_ragnar_path()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add migration detection, rag_ready state, and re-index UX to mod_document_notebook.R</name>
  <files>R/mod_document_notebook.R</files>
  <action>
Modify `mod_document_notebook.R` to add per-notebook store migration:

**1. Add rag_ready reactiveVal** (near store_healthy on line 122):
```r
rag_ready <- reactiveVal(TRUE)  # FALSE = needs migration, greyed-out controls
```

**2. Modify the existing observeEvent(notebook_id(), ...) block (lines 125-157)**

Replace the current logic. The new logic should:
- Reset both `store_healthy(NULL)` and `rag_ready(TRUE)` at the start
- Get store_path via `get_notebook_ragnar_path(nb_id)`
- Check if content exists: `docs <- list_documents(con(), nb_id)` and `has_content <- nrow(docs) > 0`
- **If has_content AND no store file**: Show migration modal (see below), set `rag_ready(FALSE)`
- **If no content AND no store**: Set `store_healthy(TRUE)` and `rag_ready(TRUE)` (empty notebook, lazy creation later)
- **If store file exists**: Run existing integrity check (`check_store_integrity`), set `store_healthy(result$ok)`, set `rag_ready(result$ok)`. If not ok, show existing rebuild modal.

Migration modal:
```r
showModal(modalDialog(
  title = "Search Index Setup Required",
  tags$p("This notebook has documents but no search index. Chat and synthesis will be unavailable until you re-index."),
  tags$p(class = "text-muted small", paste(nrow(docs), "document(s) to index.")),
  footer = tagList(
    actionButton(ns("reindex_notebook"), "Re-index Now", class = "btn-primary"),
    modalButton("Later")
  ),
  easyClose = FALSE
))
```

**3. Add async re-index infrastructure** (reactive state + ExtendedTask, following the mod_citation_network.R pattern):

Add reactive state variables for async re-indexing (near rag_ready declaration):
```r
current_interrupt_flag <- reactiveVal(NULL)
current_progress_file <- reactiveVal(NULL)
reindex_poller <- reactiveVal(NULL)
```

Add an ExtendedTask for async re-indexing:
```r
reindex_task <- ExtendedTask$new(function(notebook_id, db_path, api_key, embed_model, interrupt_flag, progress_file, app_dir) {
  mirai::mirai({
    source(file.path(app_dir, "R", "interrupt.R"), local = TRUE)
    source(file.path(app_dir, "R", "_ragnar.R"), local = TRUE)
    source(file.path(app_dir, "R", "db.R"), local = TRUE)

    result <- rebuild_notebook_store(
      notebook_id = notebook_id,
      con = NULL,
      db_path = db_path,
      api_key = api_key,
      embed_model = embed_model,
      interrupt_flag = interrupt_flag,
      progress_file = progress_file,
      progress_callback = NULL
    )
    result
  }, notebook_id = notebook_id, db_path = db_path, api_key = api_key,
     embed_model = embed_model, interrupt_flag = interrupt_flag,
     progress_file = progress_file, app_dir = app_dir)
})
```

**4. Add re-index handler** (new observeEvent — launches async task):
```r
observeEvent(input$reindex_notebook, {
  removeModal()
  nb_id <- notebook_id()
  req(nb_id)

  cfg <- config()
  api_key <- get_setting(cfg, "openrouter", "api_key")
  embed_model <- get_setting(cfg, "defaults", "embedding_model") %||% "openai/text-embedding-3-small"
  db_path <- get_setting(cfg, "app", "db_path") %||% "data/notebooks.duckdb"

  # Create interrupt and progress files
  flag_file <- create_interrupt_flag(session$token)
  progress_file <- create_progress_file(session$token)
  current_interrupt_flag(flag_file)
  current_progress_file(progress_file)

  # Show progress modal with Stop button
  showModal(modalDialog(
    title = "Re-indexing Notebook",
    div(
      div(id = ns("reindex_message"), "Initializing..."),
      div(class = "progress mt-2",
        div(class = "progress-bar progress-bar-striped progress-bar-animated",
            id = ns("reindex_bar"), role = "progressbar",
            style = "width: 0%", `aria-valuenow` = "0",
            `aria-valuemin` = "0", `aria-valuemax` = "100")
      )
    ),
    footer = actionButton(ns("cancel_reindex"), "Stop", class = "btn-warning"),
    easyClose = FALSE
  ))

  # Start progress poller
  poller <- observe({
    invalidateLater(1000)
    prog <- read_reindex_progress(current_progress_file())
    session$sendCustomMessage("updateReindexProgress", list(
      bar_id = ns("reindex_bar"),
      msg_id = ns("reindex_message"),
      pct = prog$pct,
      message = prog$message
    ))
  })
  reindex_poller(poller)

  # Launch async task
  reindex_task$invoke(nb_id, db_path, api_key, embed_model, flag_file, progress_file, getwd())
})
```

**5. Add cancel handler:**
```r
observeEvent(input$cancel_reindex, {
  flag <- current_interrupt_flag()
  if (!is.null(flag)) signal_interrupt(flag)

  # Stop polling
  poller <- reindex_poller()
  if (!is.null(poller)) poller$destroy()
  reindex_poller(NULL)

  # Update modal to show stopping state
  showModal(modalDialog(
    title = "Stopping Re-index",
    tags$p("Cancelling... please wait for current item to finish."),
    footer = NULL,
    easyClose = FALSE
  ))
})
```

**6. Add task result handler:**
```r
observe({
  result <- reindex_task$result()

  # Clean up poller
  poller <- reindex_poller()
  if (!is.null(poller)) poller$destroy()
  reindex_poller(NULL)

  # Clean up flag/progress files
  clear_interrupt_flag(current_interrupt_flag())
  clear_progress_file(current_progress_file())
  current_interrupt_flag(NULL)
  current_progress_file(NULL)

  removeModal()

  if (isTRUE(result$partial)) {
    # Cancelled mid-way — delete partial store, set rag_ready FALSE
    tryCatch(delete_notebook_store(notebook_id()), error = function(e) NULL)
    rag_ready(FALSE)
    store_healthy(FALSE)
    showNotification("Re-indexing cancelled. Partial index removed.", type = "warning", duration = 5)
  } else if (isTRUE(result$success)) {
    rag_ready(TRUE)
    store_healthy(TRUE)
    # Mark chunks as ragnar-indexed
    tryCatch({
      mark_as_ragnar_indexed(con(),
        DBI::dbGetQuery(con(), "SELECT id FROM documents WHERE notebook_id = ?", list(notebook_id()))$id,
        source_type = "document")
    }, error = function(e) message("[ragnar] Sentinel update failed: ", e$message))
    showNotification(paste("Re-indexed", result$count, "items successfully."), type = "message", duration = 5)
  } else {
    rag_ready(FALSE)
    store_healthy(FALSE)
    showNotification(paste("Re-indexing failed:", result$error), type = "error", duration = NULL)
  }
})
```

**7. Add JS handler for progress bar updates** (in the module UI function or via `tags$script` in the server):
```r
tags$script(HTML(sprintf("
  Shiny.addCustomMessageHandler('updateReindexProgress', function(data) {
    var bar = document.getElementById(data.bar_id);
    var msg = document.getElementById(data.msg_id);
    if (bar) {
      bar.style.width = data.pct + '%%';
      bar.setAttribute('aria-valuenow', data.pct);
    }
    if (msg) msg.textContent = data.message;
  });
")))
```
Place this in the module UI function (inside the `tagList(...)` return). Check if a similar handler already exists from the citation network — if so, reuse the same message name pattern or make it unique to avoid conflicts.

**5. Rewire PDF upload handler** (lines 325-344):

Replace the shared store path construction block:
```r
# OLD (remove):
ragnar_store_path <- file.path(dirname(get_setting(cfg, "app", "db_path") %||% "data/notebooks.duckdb"),
                               "serapeum.ragnar.duckdb")
store <- get_ragnar_store(ragnar_store_path, ...)
```

With per-notebook store:
```r
# Phase 22: Use per-notebook ragnar store
store <- tryCatch(
  ensure_ragnar_store(nb_id, session, api_key, embed_model),
  error = function(e) {
    message("[ragnar] Failed to open per-notebook store: ", e$message)
    NULL
  }
)
```
Always add `nb_id <- notebook_id()` at the start of the upload observeEvent handler to ensure it is in scope. Do not rely on it being defined elsewhere in the handler.

Keep the rest of the upload ragnar block (insert_chunks_to_ragnar, build_ragnar_index) as-is — they already use the `store` variable.

After the ragnar block succeeds (`ragnar_indexed <- TRUE`), add sentinel marking:
```r
if (ragnar_indexed) {
  rag_ready(TRUE)
  store_healthy(TRUE)
}
```

**6. Wire rag_available reactive to disable chat send button:**

Replace the Phase 22 placeholder comment (line 202-203) with:
```r
# Phase 22: RAG operations check both store_healthy and rag_ready
rag_available <- reactive({
  isTRUE(store_healthy()) && isTRUE(rag_ready())
})
```

**6a. Visually disable the send button when RAG is unavailable** (per locked decision: "greyed-out buttons/tooltip until they re-index"):

Find the chat send button UI (the actionButton or similar for sending chat messages). Wrap it in an `output$send_button_ui <- renderUI({...})` that reads `rag_available()`:
```r
output$send_button_ui <- renderUI({
  if (isTRUE(rag_available())) {
    actionButton(ns("send_chat"), "Send", class = "btn-primary")
  } else {
    tags$button(
      class = "btn btn-primary disabled",
      disabled = "disabled",
      title = "Chat unavailable \u2014 re-index this notebook first",
      "Send"
    )
  }
})
```
Replace the static `actionButton(ns("send_chat"), ...)` in the UI function with `uiOutput(ns("send_button_ui"))`.

**6b. Add early-return defense-in-depth guard** in the `observeEvent(input$send_chat, {...})` handler:
```r
# Defense in depth: button should be disabled, but guard anyway
if (!isTRUE(rag_available())) {
  showNotification("Chat unavailable \u2014 re-index this notebook first.", type = "warning")
  return()
}
```
Place this at the top of the send handler body, before any RAG calls.

**Important constraints:**
- Do NOT change the `observeEvent(input$rebuild_index, ...)` handler — it stays for corruption recovery
- Keep `store_healthy` for corruption, `rag_ready` for migration — separate concerns
- The `ragnar_available()` check in the upload handler (line 325) stays — it will be removed in Phase 23 (legacy code removal)
  </action>
  <verify>
Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "parse('R/mod_document_notebook.R'); cat('mod_document_notebook.R parses OK\n')"`
Grep for "serapeum.ragnar.duckdb" in R/mod_document_notebook.R — should return zero results.
Grep for "rag_ready" in R/mod_document_notebook.R — should find reactiveVal declaration and usage.
Grep for "reindex_notebook" in R/mod_document_notebook.R — should find input binding and handler.
Grep for "ExtendedTask" in R/mod_document_notebook.R — should find async task declaration.
Grep for "mirai" in R/mod_document_notebook.R — should find mirai call in ExtendedTask.
Grep for "cancel_reindex" in R/mod_document_notebook.R — should find cancel button and handler.
Grep for "signal_interrupt" in R/mod_document_notebook.R — should find interrupt signaling in cancel handler.
Grep for "read_reindex_progress" in R/mod_document_notebook.R — should find progress polling.
Grep for "ensure_ragnar_store" in R/mod_document_notebook.R — should find call in upload handler.
  </verify>
  <done>Document notebook module detects migration need, shows async cancellable re-index with per-document detail progress (e.g. "Embedding 3 of 12: Smith et al. 2023"), cancellation deletes partial store, toast notification on success, visually disables chat send button when RAG unavailable (with tooltip), and PDF uploads go to per-notebook store. No shared store references remain.</done>
</task>

</tasks>

<verification>
1. R/mod_document_notebook.R parses without errors
2. No "serapeum.ragnar.duckdb" references remain
3. rag_ready reactiveVal controls RAG feature availability
4. Migration prompt only shows for notebooks with content but no store
5. Upload handler uses ensure_ragnar_store() with per-notebook path
</verification>

<success_criteria>
- Document notebook with existing documents but no per-notebook store shows migration prompt
- Empty document notebook does not show prompt
- Chat send button is visually disabled (greyed out with tooltip) when rag_ready is FALSE
- Chat send handler has early-return guard as defense in depth
- PDF upload creates per-notebook store via ensure_ragnar_store
- Re-index uses ExtendedTask + mirai async pattern with cancellation support
- Progress modal shows per-document detail (paper/document title)
- Cancel button signals interrupt; partial store is deleted on cancellation
- Success shows toast notification
</success_criteria>

<output>
After completion, create `.planning/phases/22-module-migration/22-02-SUMMARY.md`
</output>
