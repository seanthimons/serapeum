---
phase: 22-module-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - R/db.R
  - R/_ragnar.R
  - app.R
autonomous: true

must_haves:
  truths:
    - "search_chunks_hybrid() derives per-notebook store path from notebook_id when ragnar_store_path is NULL"
    - "delete_abstract_chunks_from_ragnar() removes chunks from ragnar store by abstract ID origin prefix"
    - "mark_as_ragnar_indexed() sets sentinel embedding value for chunks table"
    - "rebuild_notebook_store() supports interrupt_flag for cancellation, progress_file for cross-process progress, and db_path for mirai workers"
    - "write_reindex_progress() and read_reindex_progress() helpers exist for async progress polling"
    - "Legacy shared store data/serapeum.ragnar.duckdb is deleted on app startup"
  artifacts:
    - path: "R/db.R"
      provides: "search_chunks_hybrid with per-notebook path derivation"
      contains: "get_notebook_ragnar_path(notebook_id)"
    - path: "R/_ragnar.R"
      provides: "delete_abstract_chunks_from_ragnar, mark_as_ragnar_indexed, write_reindex_progress, read_reindex_progress helpers; enhanced rebuild_notebook_store with interrupt/progress/db_path"
      contains: "delete_abstract_chunks_from_ragnar"
    - path: "app.R"
      provides: "Legacy shared store deletion on startup"
      contains: "serapeum.ragnar.duckdb"
  key_links:
    - from: "R/db.R"
      to: "R/_ragnar.R"
      via: "get_notebook_ragnar_path call in search_chunks_hybrid"
      pattern: "get_notebook_ragnar_path"
---

<objective>
Wire backend functions for per-notebook ragnar store usage: fix search_chunks_hybrid() path derivation, add chunk deletion and sentinel marking helpers, delete legacy shared store on startup.

Purpose: All downstream RAG callers (rag_query, generate_conclusions_preset) automatically use per-notebook stores without code changes. Helper functions enable search notebook chunk deletion and embedding tracking.

Output: Updated db.R, _ragnar.R with new helpers, app.R with shared store cleanup.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-module-migration/22-RESEARCH.md
@.planning/phases/21-store-lifecycle/21-01-SUMMARY.md
@.planning/phases/20-foundation-connection-safety/20-01-SUMMARY.md

Key references:
- R/db.R lines 836-839: search_chunks_hybrid() signature with hardcoded default
- R/db.R lines 842-843: ragnar_available() + file.exists check before store connect
- R/_ragnar.R: get_notebook_ragnar_path(), insert_chunks_to_ragnar(), build_ragnar_index() already exist
- R/rag.R lines 84-86: rag_query() calls search_chunks_hybrid(con, question, notebook_id, limit=5) — already passes notebook_id
- R/rag.R lines 306-341: generate_conclusions_preset() calls search_chunks_hybrid with notebook_id — already passes notebook_id
- app.R lines 21-25: ragnar directory creation on startup
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix search_chunks_hybrid() path default and add per-notebook derivation</name>
  <files>R/db.R</files>
  <action>
In R/db.R, modify the `search_chunks_hybrid()` function:

1. Change the default value of `ragnar_store_path` from `"data/serapeum.ragnar.duckdb"` to `NULL`.

2. Add path derivation logic at the top of the function body, BEFORE the `ragnar_available()` check:
```r
# Derive store path from notebook_id if not provided (Phase 22: per-notebook stores)
if (is.null(ragnar_store_path) && !is.null(notebook_id)) {
  ragnar_store_path <- get_notebook_ragnar_path(notebook_id)
}
```

3. The existing code at line 842 (`if (ragnar_available() && file.exists(ragnar_store_path))`) will naturally handle the case where ragnar_store_path is still NULL (file.exists(NULL) returns FALSE, so it falls through to legacy path).

4. Update the roxygen2 comment for @param ragnar_store_path to: `Path to ragnar store database (NULL to derive from notebook_id)`

Do NOT change any other part of search_chunks_hybrid(). The notebook_id filtering logic (lines 852-878) and section_filter logic (lines 882-927) remain as-is.

Verify: All existing callers in rag.R already pass notebook_id, so they will automatically get per-notebook paths without any changes to rag.R.
  </action>
  <verify>
Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "source('R/_ragnar.R'); source('R/db.R'); cat('db.R parses OK\n')"`
Grep for "serapeum.ragnar.duckdb" in R/db.R — should return zero results.
Grep for `ragnar_store_path = NULL` in R/db.R — should find the new default.
  </verify>
  <done>search_chunks_hybrid() has ragnar_store_path=NULL default and derives path from notebook_id via get_notebook_ragnar_path(). No hardcoded shared store path remains in db.R.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance rebuild_notebook_store for async, add helpers to _ragnar.R, delete shared store in app.R</name>
  <files>R/_ragnar.R, app.R</files>
  <action>
**Part A0: Enhance rebuild_notebook_store() for async re-indexing with cancellation**

Modify the existing `rebuild_notebook_store()` function in R/_ragnar.R to support:

1. Add new parameters to the function signature:
   - `interrupt_flag = NULL` — path to interrupt flag file (for cross-process cancellation via mirai)
   - `progress_file = NULL` — path to progress file (for cross-process progress reporting)
   - `db_path = NULL` — when provided, open own DBI connection (mirai workers cannot receive serialized `con`)

2. At the top of the function body, if `db_path` is not NULL and `con` is NULL, open a new connection:
```r
own_con <- FALSE
if (!is.null(db_path) && is.null(con)) {
  con <- DBI::dbConnect(duckdb::duckdb(), dbdir = db_path)
  own_con <- TRUE
  on.exit(DBI::dbDisconnect(con, shutdown = TRUE), add = TRUE)
}
```

3. In the main rebuild loop (where items are embedded one by one), between items add an interrupt check:
```r
if (!is.null(interrupt_flag) && check_interrupt(interrupt_flag)) {
  message("[ragnar] Rebuild interrupted after ", count, " of ", total, " items")
  return(list(success = FALSE, count = count, partial = TRUE, error = "Cancelled by user"))
}
```

4. In the same loop, after processing each item, write progress with the item name/title:
```r
if (!is.null(progress_file)) {
  # item_name should be derived from the current item being processed
  # For abstracts: use first_author et al. year or title substring
  # For documents: use filename
  write_reindex_progress(progress_file, count, total, item_name)
}
```
The `item_name` derivation: look at how items are fetched in the rebuild loop. For each chunk row, derive a human-readable name from its `origin` field or title. Use a truncated form: `substr(item_name, 1, 60)`.

5. Enhance the existing `progress_callback` call to include the item name:
```r
if (!is.null(progress_callback)) {
  progress_callback(count, total, item_name)
}
```
Update the progress_callback signature expectation from `function(count, total)` to `function(count, total, name)`. Existing callers that pass a 2-arg callback will still work because R ignores extra arguments.

6. Ensure the function returns a structured list: `list(success = TRUE/FALSE, count = N, partial = FALSE, error = NULL)`. If interrupted, return `list(success = FALSE, count = count, partial = TRUE, error = "Cancelled by user")`.

**Part A1: Add reindex progress helper functions to R/_ragnar.R**

Add two small helper functions for simple reindex progress (different format from citation network's BFS progress):

```r
#' Write reindex progress to file
#' Format: "count|total|message"
#' @param progress_file Path to progress file
#' @param count Current item number
#' @param total Total items
#' @param name Human-readable item name
write_reindex_progress <- function(progress_file, count, total, name) {
  if (is.null(progress_file)) return(invisible(NULL))
  pct <- round(count / max(total, 1) * 100)
  msg <- paste0("Embedding ", count, " of ", total, ": ", name)
  tryCatch(
    writeLines(paste(count, total, pct, msg, sep = "|"), progress_file),
    error = function(e) NULL
  )
  invisible(NULL)
}

#' Read reindex progress from file
#' @param progress_file Path to progress file
#' @return List with count, total, pct, message
read_reindex_progress <- function(progress_file) {
  if (is.null(progress_file) || !file.exists(progress_file)) {
    return(list(count = 0, total = 0, pct = 0, message = "Initializing..."))
  }
  line <- tryCatch(readLines(progress_file, n = 1, warn = FALSE), error = function(e) "0|0|0|Initializing...")
  parts <- strsplit(line, "\\|", fixed = FALSE)[[1]]
  if (length(parts) < 4) return(list(count = 0, total = 0, pct = 0, message = "Initializing..."))
  list(
    count = as.integer(parts[1]),
    total = as.integer(parts[2]),
    pct = as.integer(parts[3]),
    message = paste(parts[4:length(parts)], collapse = "|")
  )
}
```

**Part A2: Add two new helper functions to R/_ragnar.R** (add in the Store Lifecycle section, after `rebuild_notebook_store`):

1. `delete_abstract_chunks_from_ragnar(notebook_id, abstract_id)`:
   - Get store path via `get_notebook_ragnar_path(notebook_id)`
   - If store file doesn't exist, return invisible(NULL)
   - Connect to ragnar DuckDB directly: `DBI::dbConnect(duckdb::duckdb(), dbdir = store_path)`
   - Use `on.exit(DBI::dbDisconnect(con, shutdown = TRUE), add = TRUE)` for cleanup
   - Build origin prefix: `paste0("abstract:", abstract_id)`
   - Execute: `DBI::dbExecute(con, "DELETE FROM chunks WHERE origin LIKE ?", list(paste0(origin_prefix, "%")))` — use LIKE with % suffix (safer than starts_with which may not exist in all DuckDB versions)
   - Log with `message("[ragnar] Deleted chunks for abstract: ", abstract_id)`
   - Wrap entire body in tryCatch, log errors with `message("[ragnar] Chunk deletion failed for ", abstract_id, ": ", e$message)`
   - Add roxygen2 docs

2. `mark_as_ragnar_indexed(con, source_ids, source_type = "abstract")`:
   - If `length(source_ids) == 0`, return invisible(NULL)
   - Build parameterized query: `placeholders <- paste(rep("?", length(source_ids)), collapse = ", ")`
   - Execute: `DBI::dbExecute(con, sprintf("UPDATE chunks SET embedding = 'ragnar_indexed' WHERE source_id IN (%s) AND source_type = ?", placeholders), c(as.list(source_ids), source_type))`
   - Wrap in tryCatch, log errors
   - Add roxygen2 docs

**Part B: Delete legacy shared store on app startup in app.R**

In app.R, after the ragnar directory creation block (lines 21-25), add:

```r
# Phase 22: Delete legacy shared store (replaced by per-notebook stores)
legacy_store <- file.path("data", "serapeum.ragnar.duckdb")
if (file.exists(legacy_store)) {
  message("[ragnar] Removing legacy shared store: ", legacy_store)
  file.remove(legacy_store)
  # Also remove WAL and tmp files
  for (ext in c(".wal", ".tmp")) {
    f <- paste0(legacy_store, ext)
    if (file.exists(f)) file.remove(f)
  }
}
```
  </action>
  <verify>
Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "source('R/_ragnar.R'); cat('_ragnar.R parses OK\n')"`
Grep for "delete_abstract_chunks_from_ragnar" in R/_ragnar.R — should find the function.
Grep for "mark_as_ragnar_indexed" in R/_ragnar.R — should find the function.
Grep for "write_reindex_progress" in R/_ragnar.R — should find the function.
Grep for "read_reindex_progress" in R/_ragnar.R — should find the function.
Grep for "interrupt_flag" in R/_ragnar.R — should find parameter in rebuild_notebook_store.
Grep for "db_path" in R/_ragnar.R — should find parameter in rebuild_notebook_store.
Grep for "legacy shared store" in app.R — should find the cleanup block.
  </verify>
  <done>rebuild_notebook_store() supports interrupt_flag, progress_file, and db_path for async mirai usage. write_reindex_progress/read_reindex_progress helpers exist. delete_abstract_chunks_from_ragnar and mark_as_ragnar_indexed helpers exist. Legacy shared store is deleted on app startup in app.R.</done>
</task>

</tasks>

<verification>
1. Grep entire R/ directory for "serapeum.ragnar.duckdb" — only _ragnar.R should still reference it (in the legacy `get_ragnar_store` and `connect_ragnar_store` functions which will be removed in Phase 23), plus app.R cleanup block
2. R/db.R, R/_ragnar.R, app.R all parse without errors
3. search_chunks_hybrid() default ragnar_store_path is NULL, not the shared store path
</verification>

<success_criteria>
- search_chunks_hybrid() derives per-notebook store path from notebook_id when ragnar_store_path not provided
- rebuild_notebook_store() supports async cancellation (interrupt_flag), cross-process progress (progress_file), and mirai worker DB access (db_path)
- write_reindex_progress/read_reindex_progress helpers ready for Plan 02/03 progress polling
- delete_abstract_chunks_from_ragnar and mark_as_ragnar_indexed helpers ready for Plan 02/03 consumption
- Legacy shared store deleted on app startup
- All R files parse cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/22-module-migration/22-01-SUMMARY.md`
</output>
