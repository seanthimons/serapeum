---
phase: 08-journal-quality-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - migrations/004_create_blocked_journals.sql
  - R/db.R
  - R/mod_journal_filter.R
autonomous: true

must_haves:
  truths:
    - "blocked_journals table exists in DuckDB with journal_name, added_at columns"
    - "User can add a journal to the blocklist via add_blocked_journal()"
    - "User can remove a journal from the blocklist via remove_blocked_journal()"
    - "User can list all blocked journals via list_blocked_journals()"
    - "Journal filter module renders predatory warning badges on flagged papers"
    - "Journal filter module provides a toggle to hide/show predatory+blocked papers"
    - "Journal filter module returns filtered_papers reactive for composable filter chains"
  artifacts:
    - path: "migrations/004_create_blocked_journals.sql"
      provides: "blocked_journals table schema"
      contains: "CREATE TABLE"
    - path: "R/db.R"
      provides: "CRUD functions for blocked_journals"
      exports: ["add_blocked_journal", "remove_blocked_journal", "list_blocked_journals", "is_journal_blocked"]
    - path: "R/mod_journal_filter.R"
      provides: "Journal quality filter Shiny module"
      exports: ["mod_journal_filter_ui", "mod_journal_filter_server"]
      min_lines: 100
  key_links:
    - from: "R/mod_journal_filter.R"
      to: "R/db.R"
      via: "calls add_blocked_journal, list_blocked_journals"
      pattern: "add_blocked_journal|list_blocked_journals"
    - from: "R/mod_journal_filter.R"
      to: "R/quality_filter.R"
      via: "uses check_paper_quality for predatory detection"
      pattern: "check_paper_quality|get_predatory"
---

<objective>
Create the blocked_journals database table and a new journal quality filter Shiny module.

Purpose: Provide the data layer (personal journal blocklist) and UI module (predatory warnings + filter toggle + block action) needed for journal quality controls. Following the Phase 7 pattern: separate module that returns a filtered_papers reactive.

Output: Migration file, DB CRUD functions, mod_journal_filter.R module
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@R/db.R
@R/db_migrations.R
@R/quality_filter.R
@R/mod_keyword_filter.R
@R/mod_search_notebook.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create blocked_journals migration and DB functions</name>
  <files>migrations/004_create_blocked_journals.sql, R/db.R</files>
  <action>
1. Create `migrations/004_create_blocked_journals.sql` with:
   ```sql
   CREATE TABLE IF NOT EXISTS blocked_journals (
     id INTEGER PRIMARY KEY,
     journal_name VARCHAR NOT NULL,
     journal_name_normalized VARCHAR NOT NULL,
     added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );
   CREATE UNIQUE INDEX IF NOT EXISTS idx_blocked_journals_name ON blocked_journals(journal_name_normalized);
   ```
   Use INTEGER PRIMARY KEY with autoincrement pattern matching existing tables. The normalized name ensures no duplicate entries for the same journal.

2. Add these functions to `R/db.R` at the end of the file (before the closing comment or after the last function):

   - `add_blocked_journal(con, journal_name)` - Inserts a journal into blocked_journals. Normalizes the name using normalize_name() from quality_filter.R. Uses INSERT OR IGNORE pattern (ON CONFLICT DO NOTHING on journal_name_normalized) to prevent duplicates. Returns TRUE on success.

   - `remove_blocked_journal(con, id)` - Deletes a blocked journal by its integer id. Returns TRUE.

   - `list_blocked_journals(con)` - Returns data frame of all blocked journals ordered by added_at DESC. Columns: id, journal_name, journal_name_normalized, added_at.

   - `is_journal_blocked(con, journal_name)` - Normalizes journal_name using normalize_name(), checks if it exists in blocked_journals. Returns TRUE/FALSE. This is for fast single-check use.

   - `get_blocked_journals_set(con)` - Returns character vector of normalized journal names from blocked_journals table, for batch matching (same pattern as get_predatory_journals_set).

   Use `normalize_name()` from quality_filter.R (already sourced by app.R). Follow the exact coding style of existing db.R functions (parameter binding with ?, NULL/NA handling).
  </action>
  <verify>
Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "parse('R/db.R'); cat('OK')"`
Verify migration file exists and contains CREATE TABLE.
Verify all 5 new functions are defined in db.R.
  </verify>
  <done>
Migration SQL file exists at migrations/004_create_blocked_journals.sql. Five new functions (add_blocked_journal, remove_blocked_journal, list_blocked_journals, is_journal_blocked, get_blocked_journals_set) are defined in R/db.R and parse without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create mod_journal_filter.R module</name>
  <files>R/mod_journal_filter.R</files>
  <action>
Create a new Shiny module `R/mod_journal_filter.R` following the exact pattern of mod_keyword_filter.R (module UI/server pair, returns filtered_papers reactive).

**UI function (`mod_journal_filter_ui(id)`):**
- A compact UI that fits in a card section:
  - Toggle switch: `checkboxInput(ns("filter_predatory"), "Hide flagged journals", value = FALSE)` - default OFF per user decision JRNL-02
  - Summary line: "X of Y papers flagged" (only shown when flags exist)
  - Blocklist count: "Z journals blocked" with link to manage

**Server function (`mod_journal_filter_server(id, papers_data, con)`):**
- Accepts `papers_data` reactive (data.frame with venue column) and `con` reactive (DB connection)
- Internal reactive `quality_annotated_papers`:
  1. Load predatory journal/publisher sets from DB: `get_predatory_journals_set(con())` and `get_predatory_publishers_set(con())`
  2. Load blocked journals set: `get_blocked_journals_set(con())`
  3. For each paper, check venue against: (a) predatory journals set, (b) predatory publishers set, (c) blocked journals set using normalize_name()
  4. Add columns to papers data frame:
     - `is_predatory` (logical) - TRUE if venue matches predatory list
     - `is_blocked` (logical) - TRUE if venue matches personal blocklist
     - `is_flagged` (logical) - TRUE if either is_predatory OR is_blocked
     - `quality_flag_text` (character) - description like "Predatory journal" or "Blocked journal" or "Predatory journal (blocked)"
  5. Return annotated data frame

- Internal reactive `filtered_papers`:
  1. Get annotated papers from quality_annotated_papers()
  2. If filter toggle is ON (input$filter_predatory == TRUE): remove rows where is_flagged == TRUE
  3. Return filtered data frame

- Block journal handler:
  - Expose `block_journal` as an input event (not auto-triggered)
  - The parent module will call a custom message/event to trigger blocking
  - Actually, simpler approach: provide a reactive `block_trigger` that parent can observe
  - Better approach: return a list with filtered_papers reactive AND a block_journal function

- Return value: a list with:
  - `filtered_papers` - reactive returning filtered data frame (with quality columns attached)
  - `block_journal` - function(journal_name) that calls add_blocked_journal(con(), journal_name) and invalidates the blocklist reactive
  - `blocklist_count` - reactive returning count of blocked journals

**Key design notes:**
- This module REPLACES the existing quality flag logic in mod_search_notebook.R (the `papers_with_quality` reactive at lines 331-383). That removal happens in Plan 02.
- The module must use `normalize_name()` from quality_filter.R for consistent matching.
- Use a `reactiveVal` for blocklist refresh trigger (increment when journal is blocked/unblocked to invalidate cache).
- Keep badge rendering logic OUT of this module. The parent module (mod_search_notebook.R) already renders warning icons at line 589-595. This module just annotates the data.
  </action>
  <verify>
Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "parse('R/mod_journal_filter.R'); cat('OK')"`
Verify module exports mod_journal_filter_ui and mod_journal_filter_server.
Verify server returns a list with filtered_papers and block_journal elements.
  </verify>
  <done>
mod_journal_filter.R exists, parses without errors, exports UI and server functions. Server function accepts papers_data and con reactives, annotates papers with quality flags, provides filter toggle (default OFF), and returns list with filtered_papers reactive and block_journal function.
  </done>
</task>

</tasks>

<verification>
1. `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "parse('R/db.R'); parse('R/mod_journal_filter.R'); cat('All OK')"`
2. Verify migrations/004_create_blocked_journals.sql exists with CREATE TABLE
3. Verify R/db.R contains add_blocked_journal, remove_blocked_journal, list_blocked_journals, is_journal_blocked, get_blocked_journals_set
4. Verify R/mod_journal_filter.R contains mod_journal_filter_ui, mod_journal_filter_server
</verification>

<success_criteria>
- Migration file creates blocked_journals table with unique normalized name index
- DB CRUD functions for blocked journals follow existing code patterns
- Journal filter module annotates papers with predatory/blocked flags
- Module provides filter toggle (default OFF) and block_journal function
- All R files parse without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-journal-quality-controls/08-01-SUMMARY.md`
</output>
