---
phase: 02-query-builder-sorting
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - R/mod_query_builder.R
  - R/utils_filters.R
  - app.R
autonomous: false

must_haves:
  truths:
    - "User can type a natural language research question and receive a generated OpenAlex query"
    - "Generated query is shown to user for review before execution"
    - "LLM-generated filters are validated against an allowlist before API call"
    - "Invalid filters are rejected with an explanation message"
    - "Executing a generated query creates a search notebook with results"
  artifacts:
    - path: "R/utils_filters.R"
      provides: "OpenAlex filter allowlist and validation function"
      contains: "OPENALEX_FILTER_ALLOWLIST"
    - path: "R/mod_query_builder.R"
      provides: "Query builder Shiny module with LLM integration"
      contains: "mod_query_builder_ui"
    - path: "app.R"
      provides: "Query builder button, view routing, and producer-consumer wiring"
      contains: "mod_query_builder_server"
  key_links:
    - from: "R/mod_query_builder.R"
      to: "R/utils_filters.R"
      via: "validate_openalex_filters(parsed$filter)"
      pattern: "validate_openalex_filters"
    - from: "R/mod_query_builder.R"
      to: "R/api_openrouter.R"
      via: "chat_completion() for LLM query generation"
      pattern: "chat_completion"
    - from: "app.R"
      to: "R/mod_query_builder.R"
      via: "Producer-consumer: observeEvent(query_request()) creates notebook"
      pattern: "mod_query_builder_server"
---

<objective>
Create an LLM-powered query builder module that translates natural language research questions into validated OpenAlex filter syntax, with user review before execution.

Purpose: Researchers describe what they're looking for in plain English; the LLM handles OpenAlex filter syntax. This lowers the barrier to effective academic search.
Output: New mod_query_builder.R module, utils_filters.R validation utility, app.R wiring.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-query-builder-sorting/02-RESEARCH.md
@.planning/phases/01-seed-paper-discovery/01-02-SUMMARY.md
@R/api_openrouter.R
@R/api_openalex.R
@app.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create filter validation utility and query builder module</name>
  <files>R/utils_filters.R, R/mod_query_builder.R</files>
  <action>
**Create R/utils_filters.R — Filter validation utility:**

Create a new file with:

1. `OPENALEX_FILTER_ALLOWLIST` — character vector of valid OpenAlex work filter attribute names. Include these categories:
   - Metrics: `publication_year`, `publication_date`, `cited_by_count`, `fwci`, `authors_count`
   - Boolean: `is_oa`, `has_abstract`, `has_fulltext`, `is_retracted`
   - Categorical: `type`, `oa_status`, `language`
   - Relationships: `cites`, `cited_by`, `related_to`
   - Dates: `from_publication_date`, `to_publication_date`
   - Search: `title.search`, `abstract.search`, `default.search`, `title_and_abstract.search`, `fulltext.search`
   - Entities: `author.id`, `author.orcid`, `institutions.id`, `institutions.country_code`, `concepts.id`, `primary_topic.id`, `primary_topic.domain.id`, `primary_topic.field.id`, `primary_topic.subfield.id`, `locations.source.id`, `primary_location.source.id`, `grants.funder`

2. `validate_openalex_filters(filter_string)` — function that:
   - Returns `list(valid = TRUE, error = NULL)` if filter_string is NULL or empty
   - Splits filter_string by comma
   - For each part, extracts the attribute name (everything before the first colon)
   - Checks attribute against OPENALEX_FILTER_ALLOWLIST
   - Returns `list(valid = FALSE, error = "Invalid filter 'X': not recognized...")` on first invalid attribute
   - Returns `list(valid = TRUE, error = NULL)` if all attributes valid

**Important:** Do NOT parse filter values — only validate attribute names. Pass filter values to OpenAlex as-is (hyphenated values like `journal-article` are valid).

**Create R/mod_query_builder.R — LLM query builder module:**

Follow the producer-consumer pattern from mod_seed_discovery.R (Phase 1).

**UI function `mod_query_builder_ui(id)`:**
```
card(
  card_header("Build a Research Query"),
  card_body(
    textAreaInput(ns("nl_query"), "Describe what you're looking for:",
      placeholder = "Example: Recent high-impact papers on transformer architectures in NLP",
      rows = 3),
    actionButton(ns("generate_btn"), "Generate Query",
      class = "btn-primary", icon = icon("wand-magic-sparkles")),
    hr(),
    uiOutput(ns("query_preview"))
  )
)
```

**Server function `mod_query_builder_server(id, con, config)`:**

Reactives:
- `generated_query <- reactiveVal(NULL)` — stores parsed LLM response
- `discovery_request <- reactiveVal(NULL)` — producer output for app.R

**Generate button handler** (`observeEvent(input$generate_btn, ...)`):
1. `req(input$nl_query)` — require non-empty input
2. Get API key and model from config: `cfg <- config()`, `api_key <- get_setting(cfg, "openrouter", "api_key")`, `model <- get_setting(cfg, "openrouter", "model") %||% "anthropic/claude-sonnet-4"`
3. Check API key configured; `showNotification` warning if not
4. Wrap in `withProgress(message = "Generating query...", { ... })`
5. Build system prompt (see below)
6. Call `chat_completion(api_key, model, format_chat_messages(system_prompt, user_message))`
7. Parse response with `tryCatch(jsonlite::fromJSON(response), error = ...)` — show error notification on parse failure
8. Validate filters with `validate_openalex_filters(parsed$filter)` — show error notification if invalid
9. On success: `generated_query(parsed)`, show success notification

**System prompt** (use this exactly):
```
You are an OpenAlex API query builder. Convert research questions to OpenAlex filter syntax.

ALLOWED FILTERS (use ONLY these):
publication_year, cited_by_count, fwci, is_oa, has_abstract, is_retracted,
type, oa_status, language, from_publication_date, to_publication_date,
title.search, abstract.search, default.search

FILTER SYNTAX:
- Single: attribute:value  (e.g., publication_year:2024)
- Multiple (AND): attr1:val1,attr2:val2
- OR values: attr:val1|val2
- Comparison: cited_by_count:>100, publication_year:<2020
- Negation: type:!book

RULES:
- Only use filters from the allowed list above
- Always include has_abstract:true
- For year ranges, use from_publication_date/to_publication_date (format: YYYY-MM-DD)
- For keyword search, use default.search with key terms

OUTPUT (valid JSON only, no markdown, no code fences):
{
  "search": "keyword search terms or null",
  "filter": "comma-separated filters",
  "explanation": "plain English summary of what this query does"
}
```

**Query preview** (`output$query_preview <- renderUI(...)`):
- If `generated_query()` is NULL, return NULL
- Otherwise render:
  - Bordered div with bg-light padding
  - `h6("Generated Query")`
  - Explanation paragraph
  - Search terms (or "(none)" if null)
  - Filter string in `code()` tag
  - "Create Search Notebook" button (`ns("execute_btn")`, class = "btn-success w-100")

**Execute button handler** (`observeEvent(input$execute_btn, ...)`):
- Get `generated_query()` with `req()`
- Build filters list: `list(search = query$search, filter = query$filter)`
- Set `discovery_request(list(query = query$search, filters = filters_list, notebook_name = paste("Search:", substr(input$nl_query, 1, 50))))`

**Return:** `return(discovery_request)` — the reactive for app.R to consume.

**Important:** Use `get_setting` from R/config.R (already loaded). Use `chat_completion` and `format_chat_messages` from R/api_openrouter.R (already loaded). Use `validate_openalex_filters` from R/utils_filters.R (will be sourced by Shiny).
  </action>
  <verify>
1. Confirm file exists: `dir R\utils_filters.R R\mod_query_builder.R`
2. Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "source('R/utils_filters.R'); cat('Allowlist length:', length(OPENALEX_FILTER_ALLOWLIST), '\n'); r <- validate_openalex_filters('publication_year:2024,has_abstract:true'); cat('Valid filter:', r$valid, '\n'); r2 <- validate_openalex_filters('fake_filter:bad'); cat('Invalid filter caught:', !r2$valid, '\n')"`
3. Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "source('R/utils_filters.R'); source('R/mod_query_builder.R'); cat('UI exists:', is.function(mod_query_builder_ui), '\nServer exists:', is.function(mod_query_builder_server), '\n')"`
  </verify>
  <done>
- R/utils_filters.R exists with OPENALEX_FILTER_ALLOWLIST and validate_openalex_filters function
- R/mod_query_builder.R exists with mod_query_builder_ui and mod_query_builder_server
- Valid filters pass validation; invalid filters are rejected with explanation
- Module follows producer-consumer pattern (returns discovery_request reactive)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire query builder into app.R with sidebar button and consumer</name>
  <files>app.R</files>
  <action>
Wire the query builder module into app.R following the exact same pattern used for seed discovery (mod_seed_discovery). There are 4 insertion points:

**1. Sidebar button (near line 45-47, after the "Discover from Paper" button):**

Add a new button in the `div(class = "d-grid gap-2 mb-3")` block, after the `discover_paper` button:

```r
actionButton("build_query", "Build a Query",
             class = "btn-outline-info",
             icon = icon("wand-magic-sparkles"))
```

**2. View routing for button click (near line 232, after the discover_paper handler):**

Add an `observeEvent` for the new button:

```r
observeEvent(input$build_query, {
  current_notebook(NULL)
  current_view("query_builder")
})
```

**3. UI rendering in main content (near line 445, after the seed_discovery case):**

In the `renderUI` that switches on `current_view()`, add a case for "query_builder":

```r
if (current_view() == "query_builder") {
  return(mod_query_builder_ui("query_builder"))
}
```

Place this right after the existing seed_discovery case.

**4. Server module initialization and consumer (near line 530, after seed discovery wiring):**

Initialize the module server and add consumer observer:

```r
# Query builder module
query_request <- mod_query_builder_server("query_builder", reactive(con), config_file_r)

# Consume query builder request to create search notebook
observeEvent(query_request(), {
  req <- query_request()
  if (is.null(req)) return()

  # Create notebook with LLM-generated query
  nb_id <- create_notebook(con, req$notebook_name, "search",
                           search_query = req$query,
                           search_filters = req$filters)

  # Execute the search using existing OpenAlex search
  email <- get_setting(config_file, "openalex", "email")
  api_key <- get_setting(config_file, "openalex", "api_key")

  withProgress(message = "Searching OpenAlex...", {
    # Build search parameters from LLM output
    search_term <- req$query
    filters <- req$filters

    # Use existing search_openalex function
    results <- tryCatch({
      search_openalex(
        query = search_term,
        email = email,
        api_key = api_key,
        filters = if (!is.null(filters$filter)) filters$filter else NULL,
        per_page = 50
      )
    }, error = function(e) {
      showNotification(paste("Search error:", e$message), type = "error")
      list()
    })

    if (length(results) > 0) {
      for (paper in results) {
        existing <- dbGetQuery(con, "SELECT id FROM abstracts WHERE notebook_id = ? AND paper_id = ?",
                               list(nb_id, paper$paper_id))
        if (nrow(existing) > 0) next

        abstract_id <- create_abstract(
          con, nb_id, paper$paper_id, paper$title,
          paper$authors, paper$abstract,
          paper$year, paper$venue, paper$pdf_url,
          keywords = paper$keywords,
          work_type = paper$work_type,
          work_type_crossref = paper$work_type_crossref,
          oa_status = paper$oa_status,
          is_oa = paper$is_oa,
          cited_by_count = paper$cited_by_count,
          referenced_works_count = paper$referenced_works_count,
          fwci = paper$fwci
        )
      }
    }
  })

  # Navigate to new notebook
  current_notebook(nb_id)
  current_view("notebook")
  if (!is.null(notebook_refresh)) notebook_refresh(notebook_refresh() + 1)
  showNotification(paste("Created notebook with", length(results), "papers"), type = "message")
})
```

**Important:** Check that `search_openalex` accepts a `filters` parameter. Read the function signature in R/api_openalex.R. If it uses a different parameter name or structure, adapt the call accordingly. The LLM-generated `filters$filter` is a string like `"publication_year:>2020,has_abstract:true"` — this maps to OpenAlex's `filter=` query parameter.

**Important:** The `notebook_refresh` variable is available in the app.R server scope (check existing seed discovery consumer for reference pattern).
  </action>
  <verify>
1. Grep for `build_query` in app.R — should appear in sidebar button, observeEvent, and view routing
2. Grep for `mod_query_builder_server` in app.R — should appear in server section
3. Grep for `query_request` in app.R — should appear in observeEvent consumer
4. Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_dir('tests/testthat')"` — all tests pass
  </verify>
  <done>
- "Build a Query" button appears in sidebar
- Clicking button shows query builder UI
- Query builder module initialized in server
- Consumer creates search notebook, fetches results via OpenAlex, and navigates to notebook
- Pattern matches seed discovery wiring exactly
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify query builder end-to-end flow</name>
  <what-built>LLM-powered query builder that translates natural language to OpenAlex filters, validates them, shows preview, and creates search notebooks with results.</what-built>
  <how-to-verify>
1. Start the app: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "shiny::runApp('app.R')"`
2. Click "Build a Query" button in sidebar
3. Type: "Recent machine learning papers on transformers with high citation impact"
4. Click "Generate Query"
5. Verify: Loading spinner appears, then query preview shows with explanation, search terms, and filter string
6. Verify: Filter string contains only valid OpenAlex filters (publication_year, cited_by_count, has_abstract, etc.)
7. Click "Create Search Notebook"
8. Verify: Search notebook created with papers from OpenAlex
9. Verify: Papers display with citation metrics (no raw "NA" values)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Filter validation catches invalid filter names and passes valid ones
2. Query builder UI renders with text input, generate button, and preview area
3. LLM generates valid OpenAlex filter syntax from natural language
4. Generated query shown to user before execution (preview with explanation)
5. Creating notebook fetches papers and navigates to search notebook view
6. All existing tests pass
</verification>

<success_criteria>
- Natural language query produces validated OpenAlex filter string
- User reviews generated query before execution
- Invalid filters rejected with explanation
- Search notebook created with papers from generated query
- Producer-consumer pattern reused from Phase 1
</success_criteria>

<output>
After completion, create `.planning/phases/02-query-builder-sorting/02-02-SUMMARY.md`
</output>
