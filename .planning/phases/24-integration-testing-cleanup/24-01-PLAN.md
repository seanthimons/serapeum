---
phase: 24-integration-testing-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app.R
  - tests/testthat/test-ragnar-integration.R
autonomous: true
must_haves:
  truths:
    - "Integration test creates a notebook, inserts chunks into a per-notebook ragnar store, queries it, and verifies correct retrieval"
    - "Integration test validates section_hint encoding survives round-trip from encode through ragnar insert/retrieve and decode"
    - "Legacy shared store file is deleted on app startup with a toast notification shown to the user"
  artifacts:
    - path: "tests/testthat/test-ragnar-integration.R"
      provides: "End-to-end ragnar workflow tests with mock embeddings"
      contains: "test_that"
    - path: "app.R"
      provides: "Legacy store deletion with deferred toast notification"
      contains: "Legacy search index removed"
  key_links:
    - from: "tests/testthat/test-ragnar-integration.R"
      to: "R/_ragnar.R"
      via: "chunk_with_ragnar, insert_chunks_to_ragnar, build_ragnar_index, retrieve_with_ragnar"
      pattern: "insert_chunks_to_ragnar.*build_ragnar_index.*retrieve_with_ragnar"
    - from: "tests/testthat/test-ragnar-integration.R"
      to: "R/_ragnar.R"
      via: "encode_origin_metadata, decode_origin_metadata"
      pattern: "decode_origin_metadata.*section_hint"
    - from: "app.R"
      to: "Shiny session"
      via: "Global flag checked by one-time server observer"
      pattern: "legacy_store_deleted.*showNotification"
---

<objective>
Add a deferred toast notification for legacy shared store deletion on app startup, and create end-to-end integration tests validating the per-notebook ragnar workflow (chunk -> embed -> query -> verify) and section_hint round-trip encoding.

Purpose: Close out v3.0 by verifying the core per-notebook RAG pipeline works end-to-end and ensuring users are notified when legacy data is cleaned up.
Output: Updated app.R with toast, new test-ragnar-integration.R with passing tests
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-integration-testing-cleanup/24-RESEARCH.md

@R/_ragnar.R
@app.R
@tests/testthat/test-ragnar-helpers.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add deferred toast notification for legacy store deletion</name>
  <files>app.R</files>
  <action>
Add a global boolean flag and a deferred server observer for the legacy store deletion toast.

1. In app.R global scope (around line 29, before the existing legacy deletion block), add:
   ```r
   legacy_store_deleted <- FALSE
   ```

2. Modify the existing `if (file.exists(legacy_store))` block (lines 31-39) to set `legacy_store_deleted <- TRUE` after the file removal completes (inside the if block, after the for loop).

3. In the server function (after line 206, after the existing config notification observer), add a new one-time observer:
   ```r
   observe({
     if (legacy_store_deleted) {
       showNotification(
         "Legacy search index removed",
         type = "message",
         duration = 5
       )
     }
   }) |> bindEvent(TRUE, once = TRUE)
   ```

Per locked decisions:
- Auto-delete on startup, no user confirmation
- Delete unconditionally (already implemented)
- Toast text: "Legacy search index removed" (non-blocking)
- Clean up ALL legacy RAG files including .wal and .tmp (already implemented)
  </action>
  <verify>
Read app.R and confirm:
1. `legacy_store_deleted <- FALSE` exists in global scope before the legacy deletion block
2. `legacy_store_deleted <- TRUE` is set inside the `if (file.exists(legacy_store))` block
3. A `showNotification("Legacy search index removed", ...)` exists inside an `observe({ ... }) |> bindEvent(TRUE, once = TRUE)` block in the server function
  </verify>
  <done>App startup deletes legacy shared store files (already working) AND shows a non-blocking toast "Legacy search index removed" via a deferred server observer when deletion occurs</done>
</task>

<task type="auto">
  <name>Task 2: Create end-to-end ragnar integration tests</name>
  <files>tests/testthat/test-ragnar-integration.R</files>
  <action>
Create a new test file `tests/testthat/test-ragnar-integration.R` with integration tests that exercise the full per-notebook ragnar workflow using mock embeddings (no API calls needed).

**Setup block** (top of file):
- Source required R files: `R/db.R`, `R/_ragnar.R`, `R/config.R`
- Use project root detection pattern from existing test files (see test-ragnar-helpers.R)
- Define a ragnar availability check using the safe pattern:
  ```r
  ragnar_loadable <- tryCatch({ library(ragnar); TRUE }, error = function(e) FALSE)
  ```
- Define a mock embed function for offline testing:
  ```r
  mock_embed <- function(texts) {
    matrix(
      vapply(texts, function(t) {
        set.seed(rlang::hash(t))
        runif(16)
      }, numeric(16)),
      nrow = length(texts),
      byrow = TRUE
    )
  }
  ```

**Test 1: "ragnar workflow: chunk -> insert -> build_index -> retrieve works end-to-end"**
- `skip_if_not(ragnar_loadable, "ragnar not loadable")`
- Create temp DuckDB for notebook DB via `get_db_connection(tempfile(fileext = ".duckdb"))`
- `on.exit()` to disconnect and unlink
- `init_schema(con)` and `create_notebook(con, "Integration Test", "document")`
- Create ragnar store in `withr::local_tempdir()` at path `file.path(tmp_dir, paste0(nb_id, ".duckdb"))`
- Create store: `ragnar::ragnar_store_create(store_path, embed = mock_embed, embedding_size = 16L)`
- Create synthetic page text: 3 pages about neural networks, gradient descent, benchmarks
- Chunk with: `chunk_with_ragnar(pages, origin = "test_paper.pdf")`
- Insert: `insert_chunks_to_ragnar(store, chunks, source_id = "doc-001", source_type = "document")`
- Build index: `build_ragnar_index(store)`
- Retrieve: `retrieve_with_ragnar(store, "neural network", top_k = 3)`
- Assert: `expect_s3_class(results, "data.frame")`, `expect_true(nrow(results) > 0)`, `expect_true("text" %in% names(results))`
- Disconnect store: `DBI::dbDisconnect(store, shutdown = TRUE)`

**Test 2: "section_hint encoding survives round-trip through ragnar store"**
- `skip_if_not(ragnar_loadable, "ragnar not loadable")`
- Create temp ragnar store with mock_embed (same pattern as Test 1)
- Encode origin with section_hint: `encode_origin_metadata("paper.pdf#page=5", section_hint = "conclusion", doi = "10.1234/test", source_type = "pdf")`
- Create a single-row chunks data frame with: content="The main conclusions are significant.", page_number=5L, chunk_index=0L, context="", origin=encoded_origin
- Insert into store, build index
- Retrieve: `retrieve_with_ragnar(store, "conclusions", top_k = 1)`
- Assert: `expect_true(nrow(results) > 0)`
- Decode: `decoded <- decode_origin_metadata(results$origin[1])`
- Assert: `expect_equal(decoded$section_hint, "conclusion")`
- Disconnect store

**Test 3: "legacy shared store deletion removes all companion files"**
- No ragnar skip needed (tests file operations only)
- Create temp directory with `withr::local_tempdir()`
- Create fake legacy files: `serapeum.ragnar.duckdb`, `serapeum.ragnar.duckdb.wal`, `serapeum.ragnar.duckdb.tmp`
- Use `file.create()` to make them
- Run the same deletion logic as in app.R (replicate the pattern inline since app.R global code is not importable):
  ```r
  legacy_store <- file.path(tmp_dir, "serapeum.ragnar.duckdb")
  if (file.exists(legacy_store)) {
    file.remove(legacy_store)
    for (ext in c(".wal", ".tmp")) {
      f <- paste0(legacy_store, ext)
      if (file.exists(f)) file.remove(f)
    }
  }
  ```
- Assert: all three files are gone (`expect_false(file.exists(...))` for each)

IMPORTANT anti-patterns to avoid:
- Do NOT use `skip_if_not(requireNamespace('ragnar', quietly=TRUE))` — use the `tryCatch(library(ragnar)...)` pattern instead (renv DESCRIPTION files are broken)
- Do NOT call `retrieve_with_ragnar()` before `build_ragnar_index()` — will return 0 results
- Do NOT look for `results$section_hint` — it's encoded in `results$origin`, use `decode_origin_metadata()`
  </action>
  <verify>
Run the integration tests:
```bash
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-ragnar-integration.R')"
```
All tests should either pass or skip (if ragnar not loadable). No failures.
  </verify>
  <done>
Integration test file exists at tests/testthat/test-ragnar-integration.R with 3 tests:
1. Full workflow (chunk -> insert -> build_index -> retrieve) passes with mock embeddings
2. section_hint round-trip encoding/decoding through ragnar store passes
3. Legacy file deletion removes main DB + .wal + .tmp companion files
  </done>
</task>

</tasks>

<verification>
1. Read app.R to confirm toast notification observer exists with correct text "Legacy search index removed"
2. Run `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-ragnar-integration.R')"` — all tests pass or skip
3. Run full test suite `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_dir('tests/testthat')"` — no regressions
4. Verify no `data/serapeum.ragnar.duckdb` file exists in the project
</verification>

<success_criteria>
- app.R has a deferred toast notification "Legacy search index removed" that fires on startup when legacy store was deleted
- test-ragnar-integration.R has 3 tests covering: full ragnar workflow, section_hint round-trip, legacy file cleanup
- All tests pass (or skip if ragnar not loadable)
- Full test suite shows no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/24-integration-testing-cleanup/24-01-SUMMARY.md`
</output>
