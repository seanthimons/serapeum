---
phase: 00-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - R/db_migrations.R
  - R/db.R
  - migrations/001_bootstrap_existing_schema.sql
  - migrations/002_create_topics_table.sql
  - tests/testthat/test-db-migrations.R
autonomous: true

must_haves:
  truths:
    - "App startup applies pending migrations automatically without user action"
    - "Existing databases from before this milestone upgrade without data loss"
    - "Topics table exists in DuckDB with hierarchy columns (domain, field, subfield, topic)"
    - "Schema version is queryable via schema_migrations table"
  artifacts:
    - path: "R/db_migrations.R"
      provides: "Migration runner functions"
      exports: ["get_applied_migrations", "apply_migration", "run_pending_migrations", "bootstrap_existing_database"]
    - path: "migrations/001_bootstrap_existing_schema.sql"
      provides: "Placeholder for existing schema baseline"
      contains: "-- Bootstrap migration"
    - path: "migrations/002_create_topics_table.sql"
      provides: "Topics table DDL with hierarchy columns"
      contains: "CREATE TABLE"
    - path: "tests/testthat/test-db-migrations.R"
      provides: "Migration system tests"
      contains: "test_that"
  key_links:
    - from: "R/db.R"
      to: "R/db_migrations.R"
      via: "get_db_connection calls run_pending_migrations"
      pattern: "run_pending_migrations"
    - from: "R/db_migrations.R"
      to: "migrations/"
      via: "reads .sql files from migrations directory"
      pattern: "list\\.files.*migrations.*\\.sql"
    - from: "R/db_migrations.R"
      to: "schema_migrations table"
      via: "tracks applied versions in database"
      pattern: "schema_migrations"
---

<objective>
Create a database migration versioning system for Serapeum and add the topics table schema.

Purpose: All future phases need safe schema evolution. Currently db.R uses ad-hoc try-catch ALTER TABLE blocks (lines 102-219) with no version tracking. This plan replaces that with numbered .sql migration files that run automatically on app startup in transactions. It also creates the topics table that Phase 3 (Topic Explorer) will populate.

Output: R/db_migrations.R with migration runner, migrations/ directory with 2 SQL files, updated get_db_connection() to auto-migrate, and tests.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/00-foundation/00-RESEARCH.md
@R/db.R
@tests/testthat/test-db.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration runner and SQL migration files</name>
  <files>
    R/db_migrations.R
    migrations/001_bootstrap_existing_schema.sql
    migrations/002_create_topics_table.sql
  </files>
  <action>
Create R/db_migrations.R with these functions:

1. `get_applied_migrations(con)` - Creates schema_migrations table if not exists (version INTEGER PRIMARY KEY, description VARCHAR NOT NULL, applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP). Returns integer vector of applied version numbers.

2. `apply_migration(con, version, description, sql)` - Skips if version already applied. Otherwise wraps sql execution + version recording in `dbWithTransaction()`. Logs progress with message(). On error, logs failure and re-throws (halts startup). Returns TRUE if applied, FALSE if skipped.

3. `run_pending_migrations(con)` - Lists .sql files from migrations/ directory matching pattern `^\\d{3}_.*\\.sql$`. For each file with version > max(applied), reads SQL with readLines() and calls apply_migration(). The migrations/ path must be resolved relative to the app root, not the working directory. Use `system.file()` or detect app root by looking for app.R. Since Shiny apps run from the project root, use "migrations" as the directory path directly. Log summary: "[migration] Database at version NNN" after completion.

4. `bootstrap_existing_database(con)` - Called by run_pending_migrations when version 0 (no migrations applied yet). Checks if "notebooks" table exists via dbListTables(). If yes: this is an existing database -- mark version 001 as applied WITHOUT executing the SQL (the ad-hoc migrations in init_schema already did this work). If no: this is a fresh database -- do nothing special (init_schema + migrations will handle it).

IMPORTANT: Do NOT remove the existing ad-hoc migration code from init_schema() in db.R yet. The bootstrap logic depends on init_schema() having already run for existing databases. The ad-hoc code removal is a future cleanup task after all users have migrated past version 001.

Create migrations/001_bootstrap_existing_schema.sql:
- This is a MARKER migration only. It contains a comment explaining it represents the existing schema created by init_schema(). The actual SQL is just a no-op comment block. For fresh databases, init_schema() creates all base tables; this migration just records that version 001 baseline exists.
- Content: SQL comment explaining this is a bootstrap marker, plus a harmless SELECT 1 statement so dbExecute doesn't error on empty input.

Create migrations/002_create_topics_table.sql:
- CREATE TABLE IF NOT EXISTS topics with columns: topic_id VARCHAR PRIMARY KEY, display_name VARCHAR NOT NULL, description TEXT, keywords VARCHAR, works_count INTEGER DEFAULT 0, domain_id VARCHAR, domain_name VARCHAR, field_id VARCHAR, field_name VARCHAR, subfield_id VARCHAR, subfield_name VARCHAR, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP.
- CREATE INDEX IF NOT EXISTS idx_topics_domain ON topics(domain_id)
- CREATE INDEX IF NOT EXISTS idx_topics_field ON topics(field_id)
- CREATE INDEX IF NOT EXISTS idx_topics_subfield ON topics(subfield_id)
- CREATE INDEX IF NOT EXISTS idx_topics_works_count ON topics(works_count DESC)
- NOTE: DuckDB requires each statement to be executed separately. The migration runner must split on semicolons and execute each statement individually, OR the apply_migration function must handle multi-statement SQL. Choose the split approach: in apply_migration, split the SQL on semicolons (handling edge cases like semicolons in comments), filter empty statements, and execute each with dbExecute(). Document this behavior.
  </action>
  <verify>
Verify files exist:
- R/db_migrations.R exists and contains all 4 functions
- migrations/001_bootstrap_existing_schema.sql exists
- migrations/002_create_topics_table.sql exists and contains CREATE TABLE topics with all hierarchy columns

Syntax check: Run `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "parse('R/db_migrations.R')"` to verify R syntax is valid.
  </verify>
  <done>
Migration runner file exists with get_applied_migrations, apply_migration, run_pending_migrations, and bootstrap_existing_database functions. Two SQL migration files exist in migrations/ directory. R file parses without syntax errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire migration runner into app startup and add tests</name>
  <files>
    R/db.R
    tests/testthat/test-db-migrations.R
  </files>
  <action>
Modify get_db_connection() in R/db.R (lines 7-17):
- After opening the connection (line 15-16), add a call to `run_pending_migrations(con)` before the return. This ensures every database connection gets migrated on first use.
- The function should now be: open connection -> run_pending_migrations(con) -> return con.
- Do NOT modify init_schema() -- it must continue to work as-is for backward compatibility. The server function in app.R calls init_schema(con) on line 104 after get_db_connection(). Migrations run first (in get_db_connection), then init_schema creates base tables if missing, then migrations 002+ add new tables. This ordering is correct: bootstrap detects existing DB, skips 001, then 002 creates topics table.

Create tests/testthat/test-db-migrations.R with these test cases:

1. "get_applied_migrations creates tracking table and returns empty" - Fresh DB, call get_applied_migrations, verify schema_migrations table exists and result is empty integer vector.

2. "apply_migration records version in tracking table" - Fresh DB, create schema_migrations table, apply a test migration (CREATE TABLE test_table (id INTEGER)), verify test_table exists and version 1 is in schema_migrations.

3. "apply_migration skips already-applied versions" - Apply version 1, then apply version 1 again. Second call should return FALSE. Only one row in schema_migrations.

4. "apply_migration rolls back on SQL error" - Apply a migration with invalid SQL. Verify it throws error and version is NOT recorded in schema_migrations.

5. "run_pending_migrations applies all pending in order" - Create a temp migrations dir with two .sql files, apply. Verify both versions recorded. Use withr::with_dir() or temporarily set the migrations path if the function uses a fixed path. Alternative: if run_pending_migrations uses a hardcoded "migrations" path, create the test with a temp directory that has the right structure and cd into it, or make the migrations dir configurable via an optional parameter.

6. "bootstrap marks existing database as version 001" - Create a fresh DB, manually create a notebooks table (simulating existing DB), call bootstrap_existing_database. Verify version 1 is recorded but no new tables created.

7. "topics table created by migration 002" - Fresh DB, run init_schema then run_pending_migrations. Verify topics table exists with expected columns (topic_id, display_name, domain_id, domain_name, field_id, field_name, subfield_id, subfield_name, works_count).

Each test must create its own temp DuckDB, run the test, disconnect, and clean up. Follow the pattern in existing test-db.R. Source both R/db.R and R/db_migrations.R at top of test file.
  </action>
  <verify>
Run tests: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-db-migrations.R')"`

All 7 tests should pass. Also run existing tests to verify no regression: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-db.R')"`
  </verify>
  <done>
get_db_connection() calls run_pending_migrations() before returning. All 7 migration tests pass. Existing db tests still pass (no regression). A fresh database gets schema_migrations table + topics table on first connection. An existing database (with notebooks table) gets bootstrapped at version 001 and topics table added via migration 002.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full startup flow end-to-end:

1. Fresh database test: Delete any test DB, create connection, verify schema_migrations has versions 1 and 2, topics table exists with all columns.

2. Existing database test: Create a DB with just init_schema (no migrations), then open a new connection. Verify bootstrap marks version 001, migration 002 creates topics table, no data loss in existing tables.

3. Idempotency test: Open connection twice. Second time should skip all migrations (already applied). No errors.

4. Run full test suite: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_dir('tests/testthat')"`
</verification>

<success_criteria>
- schema_migrations table tracks applied migration versions
- Migration 001 bootstraps existing databases without re-executing init_schema
- Migration 002 creates topics table with 4-level hierarchy columns and indexes
- get_db_connection() automatically runs pending migrations
- All new tests pass, all existing tests pass
- App starts without errors on both fresh and existing databases
</success_criteria>

<output>
After completion, create `.planning/phases/00-foundation/00-01-SUMMARY.md`
</output>
