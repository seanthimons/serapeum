---
phase: 21-store-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - R/_ragnar.R
  - R/db.R
  - tests/testthat/test-ragnar-helpers.R
autonomous: true

must_haves:
  truths:
    - "Calling ensure_ragnar_store() on a notebook without a store creates one and returns a connection"
    - "Calling ensure_ragnar_store() on a notebook with an existing store connects without recreating"
    - "check_store_integrity() returns ok=FALSE for missing or corrupted stores"
    - "delete_notebook() removes the ragnar store file from disk after deleting DB records"
    - "If ragnar store file deletion fails, notebook deletion still succeeds"
    - "find_orphaned_stores() returns store files that have no matching notebook in the DB"
    - "rebuild_notebook_store() deletes the old store, re-embeds all documents and abstracts, and returns success"
  artifacts:
    - path: "R/_ragnar.R"
      provides: "Lifecycle functions: ensure_ragnar_store, check_store_integrity, delete_notebook_store, find_orphaned_stores, rebuild_notebook_store"
      contains: "ensure_ragnar_store"
    - path: "R/db.R"
      provides: "Modified delete_notebook with store cleanup cascade"
      contains: "delete_notebook_store"
    - path: "tests/testthat/test-ragnar-helpers.R"
      provides: "Tests for lifecycle functions"
      contains: "ensure_ragnar_store"
  key_links:
    - from: "R/db.R"
      to: "R/_ragnar.R"
      via: "delete_notebook calls delete_notebook_store"
      pattern: "delete_notebook_store"
    - from: "R/_ragnar.R"
      to: "R/_ragnar.R"
      via: "rebuild_notebook_store uses ensure_ragnar_store and get_notebook_ragnar_path"
      pattern: "ensure_ragnar_store|get_notebook_ragnar_path"
---

<objective>
Create the backend lifecycle functions for per-notebook ragnar stores: lazy creation, integrity checking, deletion cascade, orphan detection, and rebuild capability.

Purpose: These functions are the foundation for all store lifecycle operations. The UI layer (Plan 02) will call these functions but the logic lives here.
Output: Lifecycle functions in _ragnar.R, modified delete_notebook in db.R, tests for pure/testable functions.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-store-lifecycle/21-CONTEXT.md
@.planning/phases/21-store-lifecycle/21-RESEARCH.md
@.planning/phases/20-foundation-connection-safety/20-01-SUMMARY.md
@.planning/phases/20-foundation-connection-safety/20-02-SUMMARY.md
@R/_ragnar.R
@R/db.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lifecycle functions to _ragnar.R</name>
  <files>R/_ragnar.R</files>
  <action>
Add a new section `# ---- Store Lifecycle ----` after the existing `# ---- Version Check and Connection Lifecycle ----` section (after `register_ragnar_cleanup`). Add these functions:

**1. ensure_ragnar_store(notebook_id, session, api_key, embed_model)**
- Gets path via `get_notebook_ragnar_path(notebook_id)`
- If `file.exists(store_path)` is TRUE, call `ragnar::ragnar_store_connect(store_path)` and return the connection
- If store does NOT exist:
  - Call `showNotification("Setting up search index...", type = "message", duration = 3)` (per user decision: subtle brief indicator, not modal)
  - Call `get_ragnar_store(path = store_path, openrouter_api_key = api_key, embed_model = embed_model)` to create and return connection
  - Wrap creation in tryCatch. On error: show persistent error notification with `duration = NULL`, log with `message()`, return NULL (per user decision: block embedding action on creation failure)
- session parameter is optional (for notification display)

**2. check_store_integrity(store_path)**
- If `!file.exists(store_path)` return `list(ok = FALSE, missing = TRUE, error = "Store file not found")`
- Try `ragnar::ragnar_store_connect(store_path)` in tryCatch, immediately disconnect on success
- On success: return `list(ok = TRUE)`
- On error: return `list(ok = FALSE, missing = FALSE, error = e$message)`
- Pure function, no UI side effects

**3. delete_notebook_store(notebook_id)**
- Gets path via `get_notebook_ragnar_path(notebook_id)`
- If `!file.exists(store_path)` return TRUE (already gone)
- Try `file.remove(store_path)` in tryCatch
- Check return value of file.remove; if FALSE, log warning
- On error: log with `message("[store_lifecycle] Failed to delete store ...")`, return FALSE
- On success: return TRUE
- Also try to remove DuckDB WAL/tmp files: `file.remove(paste0(store_path, ".wal"))` and `file.remove(paste0(store_path, ".tmp"))` silently ignore failures on these

**4. find_orphaned_stores(con)**
- Get valid notebook IDs: `dbGetQuery(con, "SELECT id FROM notebooks")$id`
- List store files: `list.files(file.path("data", "ragnar"), pattern = "\\.duckdb$", full.names = TRUE)`
- If ragnar dir doesn't exist, return `character(0)`
- For each file, extract notebook_id by removing `.duckdb` extension from basename
- Filter to files whose notebook_id is NOT in valid_ids
- Also exclude any `.wal` or `.tmp` files from results
- Return character vector of orphan file paths

**5. rebuild_notebook_store(notebook_id, con, api_key, embed_model, progress_callback = NULL)**
- Gets path via `get_notebook_ragnar_path(notebook_id)`
- Delete existing store file if present (call `delete_notebook_store(notebook_id)`)
- Get documents: `list_documents(con, notebook_id)` — need doc text for re-chunking
- Get abstracts: `list_abstracts(con, notebook_id)` — need abstract text for re-embedding
- Count total items: `nrow(documents) + nrow(abstracts)`
- If total == 0, return `list(success = TRUE, count = 0)` (nothing to rebuild)
- Create new store via `get_ragnar_store(path = store_path, openrouter_api_key = api_key, embed_model = embed_model)`
- Loop over documents:
  - For each doc, call `chunk_with_ragnar(strsplit(doc$full_text, "\f")[[1]], doc$filename)` to get chunks
  - Call `insert_chunks_to_ragnar(store, chunks, doc$id, "document")`
  - If progress_callback is not NULL, call `progress_callback(count, total)` where count is items processed so far
- Loop over abstracts:
  - For each abstract, create a single-chunk data frame with the abstract text, origin = `encode_origin_metadata(paste0("abstract:", abstract$id), "general", abstract$doi, "abstract")`
  - Call `insert_chunks_to_ragnar(store, abstract_chunks, abstract$id, "abstract")`
  - If progress_callback, call it
- Call `build_ragnar_index(store)` after all inserts
- Disconnect store: `DBI::dbDisconnect(store, shutdown = TRUE)`
- Return `list(success = TRUE, count = total)`
- Wrap entire function body in tryCatch; on error return `list(success = FALSE, error = e$message, count = count_so_far)`
  </action>
  <verify>
Run `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "source('R/_ragnar.R'); cat('All lifecycle functions defined\n')"` to confirm the file sources without errors. Verify that all 5 functions exist: ensure_ragnar_store, check_store_integrity, delete_notebook_store, find_orphaned_stores, rebuild_notebook_store.
  </verify>
  <done>
Five lifecycle functions added to R/_ragnar.R in a new "Store Lifecycle" section. All functions follow patterns from research: tryCatch for errors, file.exists for checks, file.remove with return value inspection, progress_callback pattern for rebuild.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add store deletion cascade to db.R and tests for lifecycle functions</name>
  <files>R/db.R, tests/testthat/test-ragnar-helpers.R</files>
  <action>
**Part A: Modify delete_notebook() in R/db.R**

After the existing last line `dbExecute(con, "DELETE FROM notebooks WHERE id = ?", list(id))`, add:

```r
# Delete ragnar store file (Phase 21: silent cleanup on notebook deletion)
# DB records deleted first - file deletion failure is recoverable (orphan cleanup)
delete_notebook_store(id)
```

This follows the locked decision: "When notebook is deleted, store is cleaned up silently" and "If store deletion fails, notebook deletion still proceeds". The DB-first, file-second ordering follows research pitfall 4.

The function `delete_notebook_store` is defined in R/_ragnar.R which is sourced before db.R (Shiny sources R/ files alphabetically, `_ragnar.R` sorts before `db.R`).

**Part B: Add tests to test-ragnar-helpers.R**

Add a new `describe("Store Lifecycle")` block at the end of the file with these tests:

**Tests for check_store_integrity:**
- "returns ok=FALSE with missing=TRUE for non-existent file" — call with a path that doesn't exist
- "returns ok=FALSE for corrupted file" — create a temp text file with garbage content, call check_store_integrity on it (DuckDB connection will fail)

**Tests for delete_notebook_store:**
- "returns TRUE for non-existent store" — call with a random UUID
- "removes existing file and returns TRUE" — create a temp file at the expected path, call delete_notebook_store, verify file.exists returns FALSE
- "cleans up WAL file alongside main store" — create temp `.duckdb` and `.duckdb.wal` files, call delete, verify both removed

**Tests for find_orphaned_stores:**
- Skip with `skip_if_not(requireNamespace("DBI", quietly = TRUE))` and `skip_if_not(requireNamespace("duckdb", quietly = TRUE))`
- Create an in-memory DuckDB, create a notebooks table with one ID
- Create a temp ragnar directory with two `.duckdb` files (one matching the notebook ID, one orphan)
- Call find_orphaned_stores with the temp connection
- Verify only the orphan is returned

Use withr::with_tempdir() or manual temp dir cleanup for file-based tests. Clean up all temp files in test teardown.

Do NOT test ensure_ragnar_store or rebuild_notebook_store (require ragnar package + API keys).
  </action>
  <verify>
Run `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-ragnar-helpers.R')"` and confirm all tests pass with 0 failures. Also run `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-ragnar.R')"` to confirm no regressions.
  </verify>
  <done>
delete_notebook() cascades to delete_notebook_store() after all DB records are removed. New test cases for check_store_integrity, delete_notebook_store, and find_orphaned_stores all pass. No regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
1. All 5 lifecycle functions exist in R/_ragnar.R and source without errors
2. delete_notebook() in db.R calls delete_notebook_store() after DB cleanup
3. All tests pass: `testthat::test_file('tests/testthat/test-ragnar-helpers.R')`
4. No regressions: `testthat::test_file('tests/testthat/test-ragnar.R')` still passes
</verification>

<success_criteria>
- ensure_ragnar_store creates store on first call, connects on subsequent calls
- check_store_integrity returns structured result for missing, corrupted, and healthy stores
- delete_notebook_store safely removes store files with tryCatch fallback
- find_orphaned_stores compares disk files against DB notebook IDs
- rebuild_notebook_store re-chunks and re-embeds all notebook content with progress callback
- delete_notebook cascade is silent and non-blocking
- All existing + new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/21-store-lifecycle/21-01-SUMMARY.md`
</output>
