---
phase: 21-store-lifecycle
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - R/mod_document_notebook.R
  - R/mod_settings.R
autonomous: false

must_haves:
  truths:
    - "When notebook is opened, store integrity is checked and user sees modal if corrupted"
    - "User clicks Rebuild in modal, sees progress bar with item count, and store is rebuilt"
    - "Notebook remains usable during rebuild - only search/RAG is disabled"
    - "User sees orphan cleanup button in settings panel"
    - "Clicking orphan cleanup removes store files with no matching notebook"
    - "Transient store errors show toast notification"
    - "Persistent store errors (corruption) show modal with rebuild option"
  artifacts:
    - path: "R/mod_document_notebook.R"
      provides: "Proactive integrity check on notebook open, rebuild modal + progress flow, store_healthy reactive"
      contains: "check_store_integrity"
    - path: "R/mod_settings.R"
      provides: "Orphan cleanup button and status display in settings"
      contains: "find_orphaned_stores"
  key_links:
    - from: "R/mod_document_notebook.R"
      to: "R/_ragnar.R"
      via: "calls check_store_integrity and rebuild_notebook_store"
      pattern: "check_store_integrity|rebuild_notebook_store"
    - from: "R/mod_settings.R"
      to: "R/_ragnar.R"
      via: "calls find_orphaned_stores and delete_notebook_store"
      pattern: "find_orphaned_stores"
---

<objective>
Wire lifecycle functions into the UI: proactive corruption detection on notebook open, rebuild modal with progress bar, and orphan cleanup in settings.

Purpose: Users see corruption warnings with actionable rebuild, and can clean up orphaned stores from settings. This completes the store lifecycle user experience.
Output: Modified mod_document_notebook.R with integrity check + rebuild flow, modified mod_settings.R with orphan cleanup.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-store-lifecycle/21-CONTEXT.md
@.planning/phases/21-store-lifecycle/21-RESEARCH.md
@.planning/phases/21-store-lifecycle/21-01-SUMMARY.md
@R/_ragnar.R
@R/mod_document_notebook.R
@R/mod_settings.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add corruption detection and rebuild flow to mod_document_notebook.R</name>
  <files>R/mod_document_notebook.R</files>
  <action>
In `mod_document_notebook_server`, add store integrity checking and rebuild capability. This implements LIFE-04 (corruption detection) and LIFE-03 (rebuild).

**1. Add store_healthy reactiveVal**
Near the top of the moduleServer block (after existing reactive values), add:
```r
store_healthy <- reactiveVal(NULL)  # NULL = unchecked, TRUE = ok, FALSE = corrupted/missing
```

**2. Add proactive integrity check when notebook is opened**
Add an `observeEvent` on `notebook_id()` (this fires when user switches to/opens this notebook):
```r
observeEvent(notebook_id(), {
  nb_id <- notebook_id()
  req(nb_id)

  store_path <- get_notebook_ragnar_path(nb_id)

  # Only check if store file exists (no store = not yet created = ok, lazy creation handles this)
  if (!file.exists(store_path)) {
    store_healthy(TRUE)  # No store yet is fine - lazy creation will handle it
    return()
  }

  # Check integrity of existing store
  result <- check_store_integrity(store_path)
  store_healthy(result$ok)

  if (!result$ok) {
    # Persistent error: show modal with rebuild option (per user decision)
    showModal(modalDialog(
      title = "Search Index Needs Rebuild",
      tags$p("The search index for this notebook appears to be corrupted or damaged.
              This can happen after crashes or disk errors."),
      tags$p("Your documents and notes are safe. Only the search index needs rebuilding."),
      tags$p(class = "text-muted small",
             paste("Error:", result$error)),
      footer = tagList(
        actionButton(ns("rebuild_index"), "Rebuild Index", class = "btn-primary"),
        modalButton("Later")
      ),
      easyClose = FALSE
    ))
  }
})
```

Per user decision: "Proactive integrity check when notebook is opened" and "Rebuild index action appears only in error context". The modal follows the specific flow from CONTEXT: "user sees modal with explanation + Rebuild button".

**3. Add rebuild handler**
```r
observeEvent(input$rebuild_index, {
  removeModal()

  nb_id <- notebook_id()
  req(nb_id)

  cfg <- config()
  api_key <- get_setting(cfg, "openrouter", "api_key")
  embed_model <- get_setting(cfg, "defaults", "embedding_model") %||% "openai/text-embedding-3-small"

  # Rebuild with progress (per user decision: withProgress with document count)
  withProgress(message = "Rebuilding search index...", value = 0, {
    result <- rebuild_notebook_store(
      notebook_id = nb_id,
      con = con(),
      api_key = api_key,
      embed_model = embed_model,
      progress_callback = function(count, total) {
        incProgress(
          1 / total,
          detail = paste("Re-embedding", count, "/", total, "items")
        )
      }
    )
  })

  if (result$success) {
    store_healthy(TRUE)
    showNotification(
      paste("Search index rebuilt successfully.", result$count, "items re-embedded."),
      type = "message"
    )
  } else {
    store_healthy(FALSE)
    showNotification(
      paste("Rebuild failed:", result$error),
      type = "error",
      duration = NULL
    )
  }
})
```

Per user decision: "Rebuild shows progress bar with document count" and "Notebook remains fully usable during rebuild - search/RAG disabled, everything else works normally". The withProgress bar handles the feedback. The notebook remains usable because only the rebuild observeEvent blocks, not the whole module.

**4. Reactive corruption handling in RAG operations**
Find any existing code paths that call ragnar retrieval functions (e.g., `with_ragnar_store`, `connect_ragnar_store`, `retrieve_with_ragnar`). If a RAG operation fails and store_healthy is TRUE, set store_healthy to FALSE and show the rebuild modal. This implements reactive corruption detection per user decision: "Also detect corruption reactively when search/RAG operations fail".

If there are no existing RAG retrieval calls in this module yet (they may be added in Phase 22), add a comment placeholder:
```r
# Phase 22: When RAG retrieval is wired in, check store_healthy() before operations
# and set store_healthy(FALSE) + show rebuild modal on connection errors
```
  </action>
  <verify>
Source the file to confirm no syntax errors: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "tryCatch(parse(file='R/mod_document_notebook.R'), error=function(e) stop(e$message)); cat('Parse OK\n')"`. Verify check_store_integrity and rebuild_notebook_store are referenced.
  </verify>
  <done>
Proactive integrity check runs on notebook open. Corrupted stores trigger modal with "Rebuild Index" button. Rebuild uses withProgress with item-count detail. store_healthy reactiveVal tracks state for future RAG operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add orphan cleanup to mod_settings.R</name>
  <files>R/mod_settings.R</files>
  <action>
Add an orphan cleanup section to the settings panel. Per user decision: "Orphan cleanup control lives in app settings" and "simple button, not a dedicated maintenance section".

**1. Add UI elements to mod_settings_ui**
In the right column of the settings layout (after the DOI Management section and its `actionButton(ns("backfill_dois"), ...)`), add:

```r
hr(),
h5(icon("broom"), " Maintenance"),
p(class = "text-muted small",
  "Remove orphaned search index files left over from failed notebook deletions."),
actionButton(ns("cleanup_orphans"), "Clean Up Orphaned Indexes",
             class = "btn-outline-secondary btn-sm",
             icon = icon("trash-can")),
textOutput(ns("cleanup_status"))
```

Per user decision: "Orphan cleanup in settings is a simple button, not a dedicated maintenance section". Using a small subsection with descriptive text and one button.

**2. Add server handler in mod_settings_server**
After existing server logic (before the closing braces of moduleServer), add:

```r
# Orphan store cleanup (Phase 21)
observeEvent(input$cleanup_orphans, {
  orphans <- find_orphaned_stores(con())

  if (length(orphans) == 0) {
    output$cleanup_status <- renderText("No orphaned indexes found.")
    return()
  }

  # Delete orphans
  removed <- vapply(orphans, function(f) {
    tryCatch({
      result <- file.remove(f)
      # Also clean up WAL/tmp sidecar files
      suppressWarnings({
        file.remove(paste0(f, ".wal"))
        file.remove(paste0(f, ".tmp"))
      })
      result
    }, error = function(e) FALSE)
  }, logical(1))

  output$cleanup_status <- renderText(
    paste("Cleaned up", sum(removed), "of", length(orphans), "orphaned indexes.")
  )

  showNotification(
    paste("Removed", sum(removed), "orphaned search indexes."),
    type = "message"
  )
})
```

Note: `find_orphaned_stores` is defined in `R/_ragnar.R` (Plan 01). It takes a DBI connection and returns a character vector of orphan file paths. The `con()` reactive is already available in the settings server function signature.
  </action>
  <verify>
Source the file to confirm no syntax errors: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "tryCatch(parse(file='R/mod_settings.R'), error=function(e) stop(e$message)); cat('Parse OK\n')"`. Verify find_orphaned_stores is referenced. Verify the new UI elements exist (search for "cleanup_orphans" in the file).
  </verify>
  <done>
Settings panel has a Maintenance section with "Clean Up Orphaned Indexes" button. Clicking it finds orphans via find_orphaned_stores(), deletes them with error handling, and shows count to user. Simple and non-intrusive per user decision.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify store lifecycle UI</name>
  <what-built>
Complete store lifecycle: integrity check on notebook open, rebuild modal with progress, orphan cleanup in settings. Backend functions (Plan 01) + UI wiring (this plan).
  </what-built>
  <how-to-verify>
1. Start the app: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "shiny::runApp()"`
2. Open an existing notebook that has documents — verify NO corruption modal appears (store is healthy or doesn't exist yet)
3. Go to Settings tab — verify "Maintenance" section appears with "Clean Up Orphaned Indexes" button
4. Click the cleanup button — verify it shows "No orphaned indexes found" (or cleans up if orphans exist)
5. (Optional) To test rebuild: manually rename a .duckdb file in data/ragnar/ to corrupt it, then re-open the notebook — verify modal appears with "Rebuild Index" button
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Opening a notebook with corrupted store shows modal with rebuild option
2. Rebuild button triggers withProgress with "Re-embedding X/Y items" detail
3. Settings panel shows orphan cleanup button
4. Orphan cleanup correctly identifies and removes files not matching any notebook
5. No syntax errors in modified files
6. App starts and runs without errors
</verification>

<success_criteria>
- Corruption detected proactively on notebook open via check_store_integrity
- Modal appears with clear explanation and Rebuild button (not always-visible)
- Rebuild shows progress with document count per user decision
- Notebook remains usable during rebuild (search disabled, everything else works)
- Orphan cleanup button in settings finds and removes orphaned stores
- Transient errors show toast, persistent errors show modal (per error communication decisions)
</success_criteria>

<output>
After completion, create `.planning/phases/21-store-lifecycle/21-02-SUMMARY.md`
</output>
