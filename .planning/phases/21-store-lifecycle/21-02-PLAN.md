---
phase: 21-store-lifecycle
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - R/_ragnar.R
  - R/mod_document_notebook.R
  - R/mod_search_notebook.R
autonomous: true

must_haves:
  truths:
    - "When user opens a notebook with a corrupted store, a modal appears explaining the issue with a Rebuild button"
    - "When user clicks Rebuild, modal closes and progress bar shows re-embedding progress (e.g., 5/12 items)"
    - "Notebook remains fully usable during rebuild — only search/RAG is disabled"
    - "When search/RAG operation fails due to store error, user sees toast notification for transient errors"
    - "When search/RAG operation fails due to corruption, user sees modal with rebuild option"
  artifacts:
    - path: "R/_ragnar.R"
      provides: "rebuild_ragnar_store function with progress callback"
      contains: "rebuild_ragnar_store"
    - path: "R/mod_document_notebook.R"
      provides: "Integrity check on notebook open, rebuild modal, progress rebuild"
      contains: "rebuild_index"
    - path: "R/mod_search_notebook.R"
      provides: "Integrity check on notebook open, rebuild modal, progress rebuild"
      contains: "rebuild_index"
  key_links:
    - from: "R/mod_document_notebook.R"
      to: "R/_ragnar.R"
      via: "check_store_integrity() on notebook init, rebuild_ragnar_store() on rebuild click"
      pattern: "check_store_integrity\\("
    - from: "R/mod_search_notebook.R"
      to: "R/_ragnar.R"
      via: "check_store_integrity() on notebook init, rebuild_ragnar_store() on rebuild click"
      pattern: "check_store_integrity\\("
---

<objective>
Add corruption detection on notebook open and rebuild capability with progress feedback to both document and search notebook modules.

Purpose: Implements LIFE-03 (rebuild index) and LIFE-04 (corruption detection + prompt). Users can recover from corrupted stores without data loss.
Output: rebuild_ragnar_store() in _ragnar.R, integrity checks + rebuild UI in both notebook modules.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-store-lifecycle/21-01-SUMMARY.md
@.planning/phases/21-store-lifecycle/21-RESEARCH.md
@R/_ragnar.R
@R/mod_document_notebook.R
@R/mod_search_notebook.R
@R/db.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rebuild function to _ragnar.R and wire integrity check + rebuild into mod_document_notebook.R</name>
  <files>R/_ragnar.R, R/mod_document_notebook.R</files>
  <action>
**In R/_ragnar.R — add rebuild_ragnar_store() to the Store Lifecycle section (created in Plan 01):**

```r
rebuild_ragnar_store <- function(notebook_id, con, openrouter_api_key, embed_model, progress_fn = NULL)
```

This function:
1. Gets store path via `get_notebook_ragnar_path(notebook_id)`
2. Deletes corrupted store file: `delete_ragnar_store(notebook_id)` (from Plan 01)
3. Gathers all content for this notebook from DB:
   - Documents: `dbGetQuery(con, "SELECT id, filename, full_text, page_count FROM documents WHERE notebook_id = ?", list(notebook_id))`
   - Abstracts: `dbGetQuery(con, "SELECT id, title, abstract FROM abstracts WHERE notebook_id = ?", list(notebook_id))`
4. Calculate total items: `nrow(documents) + nrow(abstracts)`
5. If total is 0, return early (nothing to rebuild — store will be created lazily on next embed)
6. Create new store via `get_ragnar_store(path, openrouter_api_key, embed_model)`
7. Re-embed documents: for each document row, if full_text is not NULL/empty:
   - Chunk via `chunk_with_ragnar(strsplit(full_text, "\\f")[[1]], filename)` — pages split by form-feed (existing pattern)
   - Use `encode_origin_metadata()` to set origin with section_hint="general", source_type="pdf"
   - Insert via `ragnar::ragnar_store_insert(store, data.frame(text=chunks$content, origin=chunks$origin))`
   - Call `progress_fn(current_item, total_items)` if provided
8. Re-embed abstracts: for each abstract row, if abstract text is not NULL/empty:
   - Create single-chunk data frame with origin encoded via `encode_origin_metadata(paste0("abstract:", id), "general", doi=NA, source_type="abstract")`
   - Insert via `ragnar::ragnar_store_insert(store, ...)`
   - Call `progress_fn(current_item, total_items)` if provided
9. Build index: `ragnar::ragnar_store_build_index(store)`
10. Close store: `DBI::dbDisconnect(store, shutdown = TRUE)`
11. Return `list(ok = TRUE, items = total_items)`

IMPORTANT: Wrap the entire rebuild in tryCatch. On error, return `list(ok = FALSE, error = e$message)`. Clean up store connection in on.exit().

NOTE: Check how documents store full_text — look at existing PDF upload flow in mod_document_notebook.R to confirm the full_text format (pages joined by form-feed `\f` or stored differently). Adjust chunking accordingly. If full_text is just a single string, chunk it directly without splitting.

**In R/mod_document_notebook.R — add integrity check and rebuild flow:**

1. **Integrity check on notebook initialization:**
   In the server function, find where the notebook_id is first available/set (likely a reactive or observe that loads notebook data). Add an integrity check:

   ```r
   # Check store integrity when notebook loads
   observe({
     req(notebook_id())
     store_path <- get_notebook_ragnar_path(notebook_id())

     # Only check if store file exists (no store = not yet created, which is fine)
     if (file.exists(store_path)) {
       health <- check_store_integrity(notebook_id())
       if (!health$ok) {
         # Persistent error: show modal with rebuild option
         showModal(modalDialog(
           title = "Search Index Needs Rebuild",
           p("The search index for this notebook appears to be corrupted or damaged."),
           p("Your documents and content are safe. Rebuilding will re-create the search index."),
           p(class = "text-muted small", paste("Reason:", health$reason)),
           footer = tagList(
             actionButton(ns("rebuild_index"), "Rebuild Index", class = "btn-primary", icon = icon("rotate")),
             modalButton("Later")
           ),
           easyClose = FALSE
         ))
       }
     }
   }) |> bindEvent(notebook_id())
   ```

   Per user decision: proactive check when notebook is opened, modal for persistent errors, "Rebuild index" only in error context.

2. **Rebuild handler:**
   ```r
   observeEvent(input$rebuild_index, {
     removeModal()

     req(notebook_id())
     nb_id <- notebook_id()

     withProgress(message = "Rebuilding search index...", value = 0, {
       rebuild_ragnar_store(
         notebook_id = nb_id,
         con = con,
         openrouter_api_key = settings$openrouter_key(),
         embed_model = settings$embed_model(),
         progress_fn = function(current, total) {
           incProgress(1/total, detail = paste("Re-embedding", current, "/", total, "items"))
         }
       )
     })

     showNotification("Search index rebuilt successfully!", type = "message", duration = 5)
   })
   ```

   Per user decision: progress bar with document count, notebook remains usable (just search disabled).

3. **Reactive corruption detection:**
   In any existing RAG/search operation calls (look for `with_ragnar_store` or `ragnar_retrieve` calls), wrap in tryCatch and distinguish transient vs persistent errors:
   - If a search/RAG call fails, show toast: `showNotification(paste("Search error:", e$message), type = "warning", duration = 5)`
   - If error message suggests corruption (contains "corrupt", "invalid", or connection fails repeatedly), show the rebuild modal instead

   Find the existing pattern and add error classification. This may be a simple addition to the existing error handling — check what error handling already exists around RAG operations.

NOTE: Check how the server function receives `con`, `settings`, and `notebook_id` — these are likely passed as module parameters or reactive values. Use the same pattern.
  </action>
  <verify>
Run `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "source('R/_ragnar.R'); cat('_ragnar.R sources OK\n')"` — verify rebuild_ragnar_store exists.

Run `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "library(shiny); library(bslib); source('R/_ragnar.R'); source('R/db.R'); source('R/mod_document_notebook.R'); cat('mod_document_notebook.R sources OK\n')"` — sources without error.

Grep mod_document_notebook.R for "rebuild_index", "check_store_integrity", "rebuild_ragnar_store" — all present.
  </verify>
  <done>rebuild_ragnar_store() function exists in _ragnar.R with progress callback support. mod_document_notebook.R checks store integrity on notebook open, shows rebuild modal on corruption, rebuilds with progress bar on user action.</done>
</task>

<task type="auto">
  <name>Task 2: Wire integrity check and rebuild into mod_search_notebook.R</name>
  <files>R/mod_search_notebook.R</files>
  <action>
Apply the same integrity check and rebuild pattern from Task 1 to mod_search_notebook.R.

1. **Integrity check on notebook initialization:**
   Find where notebook_id is first available in the search notebook server. Add the same integrity check observe block as in Task 1 — check store health when notebook opens, show modal if corrupted.

   Use identical modal structure (title "Search Index Needs Rebuild", explanation, Rebuild button with id `ns("rebuild_index")`).

2. **Rebuild handler:**
   Add identical `observeEvent(input$rebuild_index, { ... })` handler with `withProgress` and `rebuild_ragnar_store()` call.

   NOTE: The search notebook module may receive different parameter names for the DB connection, API key, and embed model. Read the module's server function signature to identify the correct parameter names and use those.

3. **Reactive corruption detection in search/RAG operations:**
   Find existing search/RAG calls in mod_search_notebook.R (likely around abstract embedding or synthesis operations). Add the same error classification pattern:
   - Transient errors: toast notification
   - Persistent/corruption errors: rebuild modal

   Per user decision: never block content ingestion (abstract saving) due to store errors — save to DB regardless, notify user that search is unavailable.

NOTE: The search notebook handles abstracts (not PDFs). The rebuild will re-embed abstracts. Ensure the rebuild_ragnar_store function handles the case where a search notebook has abstracts but no documents.
  </action>
  <verify>
Run `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "library(shiny); library(bslib); source('R/_ragnar.R'); source('R/db.R'); source('R/mod_search_notebook.R'); cat('mod_search_notebook.R sources OK\n')"` — sources without error.

Grep mod_search_notebook.R for "rebuild_index", "check_store_integrity", "rebuild_ragnar_store" — all present.

Run full test suite: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_dir('tests/testthat')"` — all tests pass.
  </verify>
  <done>mod_search_notebook.R checks store integrity on notebook open, shows rebuild modal on corruption, rebuilds with progress. Transient errors show toast, persistent errors show modal. Content ingestion never blocked by store errors. All tests pass.</done>
</task>

</tasks>

<verification>
1. rebuild_ragnar_store() exists in R/_ragnar.R and handles both documents and abstracts
2. mod_document_notebook.R has integrity check on open + rebuild handler with progress
3. mod_search_notebook.R has integrity check on open + rebuild handler with progress
4. Both modules show modal on corruption with Rebuild button (only in error context, per user decision)
5. Both modules show toast for transient errors, modal for persistent errors
6. Content ingestion is never blocked by store errors
7. All files source without error
8. All existing tests pass (no regression)
</verification>

<success_criteria>
- Corrupted/missing store detected proactively when notebook opens
- Rebuild modal appears only in error context (not always-visible menu item)
- Rebuild shows progress bar with item count (e.g., "Re-embedding 5/12 items")
- Notebook remains usable during rebuild (search disabled, everything else works)
- Transient store errors show toast; persistent errors show modal with rebuild
- Content ingestion (PDF upload, abstract save) never blocked by store errors
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/21-store-lifecycle/21-02-SUMMARY.md`
</output>
