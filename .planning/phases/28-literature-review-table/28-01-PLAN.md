---
phase: 28-literature-review-table
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - R/rag.R
  - R/mod_document_notebook.R
  - app.R
autonomous: true

must_haves:
  truths:
    - "User sees a Lit Review button in the document notebook preset panel"
    - "User clicks Lit Review and receives a GFM markdown table with one row per paper and columns: Author/Year, Methodology, Sample, Key Findings, Limitations"
    - "Table renders with Bootstrap styling, horizontal scroll, sticky headers, and frozen first column in the chat panel"
    - "AI-generated content disclaimer appears on lit review output"
    - "When the LLM produces malformed output, the user sees a clear error message rather than garbled text"
  artifacts:
    - path: "R/rag.R"
      provides: "build_context_by_paper(), validate_gfm_table(), generate_lit_review_table() functions"
      contains: "generate_lit_review_table"
    - path: "R/mod_document_notebook.R"
      provides: "Lit Review button, observeEvent handler, disclaimer check update, HTML post-processing for scroll wrapper"
      contains: "btn_lit_review"
    - path: "app.R"
      provides: "CSS for .lit-review-scroll container with frozen first column"
      contains: "lit-review-scroll"
  key_links:
    - from: "R/mod_document_notebook.R"
      to: "R/rag.R"
      via: "observeEvent calls generate_lit_review_table()"
      pattern: "generate_lit_review_table\\("
    - from: "R/mod_document_notebook.R"
      to: "chat message renderer"
      via: "preset_type = lit_review triggers AI disclaimer and scroll wrapper"
      pattern: "lit_review"
    - from: "app.R"
      to: "R/mod_document_notebook.R"
      via: "CSS .lit-review-scroll styles the wrapper div injected in message renderer"
      pattern: "lit-review-scroll"
---

<objective>
Add a Literature Review Table synthesis preset to the document notebook that generates a structured per-paper comparison matrix (Author/Year, Methodology, Sample, Key Findings, Limitations) from all papers in the notebook.

Purpose: Researchers can generate a side-by-side comparison of their uploaded papers' methodology, sample, findings, and limitations — the primary structured output needed for literature reviews.
Output: Working Lit Review button in document notebook preset panel, generating a scrollable GFM table with frozen first column and Bootstrap styling.
</objective>

<execution_context>
@/home/sean/.claude/get-shit-done/workflows/execute-plan.md
@/home/sean/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/sean/Documents/serapeum/.planning/PROJECT.md
@/home/sean/Documents/serapeum/.planning/ROADMAP.md
@/home/sean/Documents/serapeum/.planning/STATE.md
@/home/sean/Documents/serapeum/.planning/phases/28-literature-review-table/28-CONTEXT.md
@/home/sean/Documents/serapeum/.planning/phases/28-literature-review-table/28-RESEARCH.md
@/home/sean/Documents/serapeum/R/rag.R
@/home/sean/Documents/serapeum/R/mod_document_notebook.R
@/home/sean/Documents/serapeum/app.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add build_context_by_paper(), validate_gfm_table(), and generate_lit_review_table() to rag.R</name>
  <files>R/rag.R</files>
  <action>
Add three new functions after `generate_research_questions()` (after line ~570) in R/rag.R.

**1. build_context_by_paper() — groups chunks under per-paper delimiters:**

```r
build_context_by_paper <- function(papers_with_chunks) {
  # Input: list of lists, each with $filename, $doc_id, $chunks (data frame with content, page_number, section_hint)
  # Output: single string with === PAPER: filename === delimiters
```

For each paper in the list:
- Format each chunk as `[p.{page_number}, {section_hint}] {content}` (use COALESCE'd section_hint so it's never NA — use "general" as fallback)
- Wrap all chunks under `=== PAPER: {filename} ===` delimiter
- Join papers with double newlines

Use `vapply(..., character(1))` for both inner chunk formatting and outer paper formatting. Join with `paste(sections, collapse = "\n\n")`.

**2. validate_gfm_table() — regex pipe-count validation:**

```r
validate_gfm_table <- function(text) {
```

- Split text on newlines
- Filter to lines containing `|` (pipe), trim whitespace, drop empty lines
- Return FALSE if fewer than 3 table lines (need header + separator + at least 1 data row)
- Count pipes per line with `nchar(gsub("[^|]", "", l))`
- Return TRUE only if all lines have the same pipe count (i.e., `length(unique(pipe_counts)) == 1`)
- Use `USE.NAMES = FALSE` on vapply

**3. generate_lit_review_table() — the main function:**

```r
generate_lit_review_table <- function(con, config, notebook_id, session_id = NULL)
```

Follow the `generate_conclusions_preset()` structure (lines 237-393) with these specific differences:

**API setup (identical to conclusions):**
- Extract api_key via `get_setting(config, "openrouter", "api_key")`, guard against vector with `if (length(api_key) > 1) api_key <- api_key[1]`
- Extract chat_model via `get_setting(config, "defaults", "chat_model")` with fallback `%||% "anthropic/claude-sonnet-4"`
- Return early with error string if api_key empty

**Document retrieval:**
- Call `list_documents(con, notebook_id)` to get all documents
- Return early with "No documents found in this notebook." if 0 rows
- Store `paper_count <- nrow(docs)`

**Section-aware chunk retrieval per paper:**
- Set `chunks_per_paper <- 7L` and `max_context_tokens <- 80000L`
- For each document, FIRST try section-filtered SQL:
  ```sql
  SELECT chunk_index, content, page_number, COALESCE(section_hint, 'general') as section_hint
  FROM chunks
  WHERE source_id = ? AND section_hint IN ('methods', 'methodology', 'results', 'limitations', 'discussion', 'conclusion')
  ORDER BY chunk_index
  LIMIT ?
  ```
- If section query returns fewer than 2 rows, FALLBACK to distributed sampling:
  ```sql
  SELECT chunk_index, content, page_number, COALESCE(section_hint, 'general') as section_hint
  FROM chunks WHERE source_id = ?
  ORDER BY chunk_index
  ```
  Then sample: first 2 + middle + last 2 indices (capped at chunks_per_paper). Use `unique(c(1, 2, ceiling(n/2), n-1, n))`, filter to valid range `[1, n]`, take `head(indices, chunks_per_paper)`.
- Build `papers_data` as a list of lists: `list(filename = doc$filename, doc_id = doc$id, chunks = section_chunks)`

**Dynamic token budget:**
- After initial retrieval, estimate total tokens: `sum(vapply(papers_data, function(p) ceiling(nchar(paste(p$chunks$content, collapse = " ")) / 4), numeric(1)))`
- If over `max_context_tokens` and `chunks_per_paper > 2L`, reduce `chunks_per_paper` by 1 and re-query in a `repeat` loop. Break when under budget or at minimum 2 chunks/paper.
- If still over budget at 2 chunks/paper, return graceful error: `"The combined document content exceeds the analysis limit. Consider splitting documents across multiple notebooks or removing some documents."`

**Build context:**
- Call `build_context_by_paper(papers_data)` for the per-paper delimited context string

**System prompt — CRITICAL, use this exact text:**
```
You are a systematic review assistant. Generate a literature review comparison table in GFM (GitHub-Flavored Markdown) pipe table format.

REQUIRED COLUMNS (in this exact order):
| Author/Year | Methodology | Sample | Key Findings | Limitations |

RULES:
- One row per paper. Extract Author(s) and Year from the paper content itself.
- Author/Year format: "LastName et al. (2023)" for 3+ authors, "A & B (2023)" for two, "LastName (2023)" for one.
- Use brief phrases per cell (2-5 words), e.g., "RCT, double-blind", "N=245 undergrads".
- Key Findings: single consolidated statement per paper (no bullet points).
- For inapplicable columns, use contextual notes like "Theoretical framework" or "Systematic review (no primary data)" instead of literal "N/A".
- Order rows reverse chronologically (most recent first).
- Output ONLY the markdown table. No preamble, no notes after the table.
- Every row must have exactly 5 columns separated by pipes.
```

**User prompt:**
```
===== DOCUMENTS =====
{context}
===== END =====

Generate the literature review comparison table for the {paper_count} paper(s) above.
```

**LLM call and cost logging:**
- Use `format_chat_messages(system_prompt, user_prompt)` then `chat_completion(api_key, chat_model, messages)`
- Log cost with category `"lit_review_table"` (same pattern as conclusions/research_questions)

**Post-LLM validation:**
- Call `validate_gfm_table(result$content)`
- If invalid, return: `"The generated table appears malformed. Please try again by clicking the Lit Review button."`
- If valid, return `result$content`

**Error handling:** Wrap the LLM call in tryCatch, return error string on failure: `sprintf("Error generating literature review table: %s", e$message)`

IMPORTANT: The `documents` table has NO author/year/DOI metadata — only filename, filepath, full_text, page_count. Author/Year extraction is done by the LLM from document content. Do NOT attempt DOI injection — it is not possible without stored DOIs. Per research findings, filename serves as fallback paper identifier in the build_context_by_paper() delimiters.
  </action>
  <verify>
1. Grep for `build_context_by_paper` in R/rag.R — function definition exists with `=== PAPER:` delimiter pattern.
2. Grep for `validate_gfm_table` in R/rag.R — function exists with pipe count validation logic.
3. Grep for `generate_lit_review_table` in R/rag.R — function exists with: `list_documents`, `section_hint`, `build_context_by_paper`, `validate_gfm_table`, `format_chat_messages`, `chat_completion`, `log_cost.*lit_review_table`.
4. Grep for `max_context_tokens` — dynamic token budget check present.
  </verify>
  <done>
Three functions exist in rag.R: `build_context_by_paper()` groups chunks under per-paper delimiters, `validate_gfm_table()` checks pipe count consistency, and `generate_lit_review_table()` retrieves section-prioritized chunks per document with dynamic token budgeting, sends a single LLM call, validates the GFM output, and logs cost under "lit_review_table".
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Lit Review button and handler in mod_document_notebook.R</name>
  <files>R/mod_document_notebook.R</files>
  <action>
Make four changes to R/mod_document_notebook.R:

**1. Add button to preset bar (UI function, after the Slides button at line 64):**

Inside the `btn-group` div, after the Slides actionButton, add:
```r
actionButton(ns("btn_lit_review"), "Lit Review",
             class = "btn-sm btn-outline-primary",
             icon = icon("table-cells"))
```

This follows the static button pattern used by all other document notebook presets. Use the `table-cells` Font Awesome icon (verified: exists in FA6 solid set).

**2. Update disclaimer check (line 600):**

Change:
```r
is_synthesis <- !is.null(msg$preset_type) && msg$preset_type %in% c("conclusions", "research_questions")
```
To:
```r
is_synthesis <- !is.null(msg$preset_type) && msg$preset_type %in% c("conclusions", "research_questions", "lit_review")
```

**3. Add HTML post-processing for lit review messages in the message renderer:**

In the assistant message rendering block (around line 613 where `commonmark::markdown_html` is called), add conditional post-processing. After the existing `HTML(commonmark::markdown_html(msg$content, extensions = TRUE))` line, wrap the logic so that for lit_review messages, the HTML gets table wrapper injection:

Replace the single line:
```r
HTML(commonmark::markdown_html(msg$content, extensions = TRUE))
```

With a block that checks preset_type:
```r
{
  rendered_html <- commonmark::markdown_html(msg$content, extensions = TRUE)
  if (!is.null(msg$preset_type) && identical(msg$preset_type, "lit_review")) {
    rendered_html <- gsub("<table>",
      '<div class="lit-review-scroll"><table class="table table-striped table-bordered">',
      rendered_html)
    rendered_html <- gsub("</table>", "</table></div>", rendered_html)
  }
  HTML(rendered_html)
}
```

This wraps the `<table>` in a `.lit-review-scroll` div and adds Bootstrap table classes. The CSS in app.R will handle the scroll/sticky behavior.

**4. Add observeEvent handler (after the conclusions handler, around line 755):**

Clone the conclusions handler pattern (lines 734-755) with these changes:

```r
# Literature Review Table
observeEvent(input$btn_lit_review, {
  req(!is_processing())
  req(has_api_key())

  # Guard: RAG must be available
  if (!isTRUE(rag_available())) {
    showNotification("Synthesis unavailable - re-index this notebook first.", type = "warning")
    return()
  }

  is_processing(TRUE)

  # Warning toast for large notebooks
  nb_id <- notebook_id()
  doc_count <- tryCatch({
    nrow(list_documents(con(), nb_id))
  }, error = function(e) 0L)
  if (doc_count >= 20L) {
    showNotification(
      sprintf("Analyzing %d papers - output quality may degrade with this many documents.", doc_count),
      type = "warning", duration = 8
    )
  }

  msgs <- messages()
  msgs <- c(msgs, list(list(
    role = "user",
    content = "Generate: Literature Review Table",
    timestamp = Sys.time(),
    preset_type = "lit_review"
  )))
  messages(msgs)

  cfg <- config()

  response <- tryCatch({
    generate_lit_review_table(con(), cfg, nb_id, session_id = session$token)
  }, error = function(e) {
    sprintf("Error: %s", e$message)
  })

  msgs <- c(msgs, list(list(
    role = "assistant",
    content = response,
    timestamp = Sys.time(),
    preset_type = "lit_review"
  )))
  messages(msgs)
  is_processing(FALSE)
})
```

Key details:
- RAG availability guard (same pattern as conclusions but explicit since document notebook uses static buttons)
- Warning toast at 20+ papers per CONTEXT.md decision
- `preset_type = "lit_review"` on both user and assistant messages (triggers disclaimer + scroll wrapper)
- Place this handler BEFORE the slides module/handler block (before line 757 `# Slides module`)
  </action>
  <verify>
1. Grep for `btn_lit_review` in R/mod_document_notebook.R — appears in UI (actionButton) and handler (observeEvent).
2. Grep for `lit_review` in R/mod_document_notebook.R — appears in disclaimer check, preset_type assignments, and HTML post-processing.
3. Grep for `generate_lit_review_table` in R/mod_document_notebook.R — appears in the observeEvent handler.
4. Grep for `lit-review-scroll` in R/mod_document_notebook.R — appears in the gsub HTML post-processing.
5. Grep for `table-cells` in R/mod_document_notebook.R — icon used for the button.
  </verify>
  <done>
Document notebook has a "Lit Review" button in the preset panel that: calls generate_lit_review_table() on click, warns at 20+ papers, adds user and assistant messages with preset_type "lit_review", triggers the AI-generated content disclaimer, and wraps the rendered table HTML in a `.lit-review-scroll` div with Bootstrap table classes for horizontal scroll and frozen first column styling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CSS for scrollable lit review table with frozen first column in app.R</name>
  <files>app.R</files>
  <action>
Add CSS rules for the `.lit-review-scroll` container in app.R's existing `tags$style(HTML(...))` block (after the existing `.chat-markdown` rules ending around line 96).

Add these rules INSIDE the existing `tags$style(HTML("..."))` string, after the `.chat-markdown ul, .chat-markdown ol` rule at line 96:

```css
/* Literature review table: horizontal scroll + frozen first column */
.chat-markdown .lit-review-scroll {
  overflow-x: auto;
  max-width: 100%;
  border: 1px solid #dee2e6;
  border-radius: 0.25rem;
  margin: 0.5em 0;
}
.chat-markdown .lit-review-scroll table {
  min-width: 800px;
  border-collapse: separate;
  border-spacing: 0;
  width: auto;
}
.chat-markdown .lit-review-scroll th:first-child,
.chat-markdown .lit-review-scroll td:first-child {
  position: sticky;
  left: 0;
  z-index: 1;
  background-color: #f1f3f5;
  border-right: 2px solid #adb5bd;
  min-width: 140px;
}
.chat-markdown .lit-review-scroll thead th {
  position: sticky;
  top: 0;
  z-index: 2;
  background-color: #f1f3f5;
}
.chat-markdown .lit-review-scroll thead th:first-child {
  z-index: 3;
}
```

Key CSS details:
- `overflow-x: auto` on the wrapper enables horizontal scrolling
- `min-width: 800px` on the table forces it wider than chat panel to trigger scroll
- `width: auto` overrides the existing `.chat-markdown table { width: 100% }` that would prevent scrolling
- `position: sticky; left: 0` on first-child th/td freezes the Author/Year column
- z-index layering: 1 (frozen column), 2 (sticky header), 3 (corner cell — both sticky)
- `border-collapse: separate` is required for sticky positioning to work (collapse breaks it)
- `border-right: 2px solid #adb5bd` provides visual separation for the frozen column
- `min-width: 140px` on first column ensures Author/Year has enough space

Also add dark theme variants to handle bslib dark mode:
```css
[data-bs-theme="dark"] .chat-markdown .lit-review-scroll {
  border-color: #495057;
}
[data-bs-theme="dark"] .chat-markdown .lit-review-scroll th:first-child,
[data-bs-theme="dark"] .chat-markdown .lit-review-scroll td:first-child,
[data-bs-theme="dark"] .chat-markdown .lit-review-scroll thead th {
  background-color: #2b3035;
  border-color: #495057;
}
```

Do NOT modify any existing CSS rules. Only append new rules.
  </action>
  <verify>
1. Grep for `lit-review-scroll` in app.R — CSS rules exist for the scroll container, frozen column, sticky header, and dark theme.
2. Grep for `position: sticky` in app.R — appears for both first-child and thead th selectors.
3. Grep for `z-index: 3` in app.R — corner cell has highest z-index.
4. Grep for `data-bs-theme.*dark.*lit-review` in app.R — dark theme variants exist.
  </verify>
  <done>
app.R contains CSS for `.lit-review-scroll` that provides: horizontal scroll on the wrapper div, frozen first column (Author/Year) via sticky positioning, sticky column headers, proper z-index layering for the corner cell, min-width to force scroll, and dark theme variants for bslib compatibility.
  </done>
</task>

</tasks>

<verification>
1. `grep -n "build_context_by_paper\|validate_gfm_table\|generate_lit_review_table" R/rag.R` — all three functions defined
2. `grep -n "btn_lit_review" R/mod_document_notebook.R` — button in UI and handler
3. `grep -n "lit_review" R/mod_document_notebook.R` — disclaimer check, preset_type, HTML post-processing
4. `grep -n "lit-review-scroll" app.R R/mod_document_notebook.R` — CSS in app.R, wrapper injection in module
5. `grep -n "log_cost.*lit_review_table" R/rag.R` — cost logging with correct category
6. `grep -n "max_context_tokens\|chunks_per_paper" R/rag.R` — dynamic token budget present
7. `grep -n "section_hint.*IN" R/rag.R` — section-aware SQL queries present
8. `grep -n "data-bs-theme.*dark" app.R` — dark theme CSS variants exist
</verification>

<success_criteria>
- build_context_by_paper() groups chunks under `=== PAPER: filename ===` delimiters
- validate_gfm_table() checks pipe count consistency across all table lines
- generate_lit_review_table() exists as a standalone function in rag.R (NOT inside generate_preset())
- Function retrieves chunks per document with section_hint prioritization and distributed sampling fallback
- Dynamic token budget starts at 7 chunks/paper, reduces iteratively, refuses gracefully if over limit at minimum
- System prompt specifies exactly 5 columns: Author/Year, Methodology, Sample, Key Findings, Limitations
- LLM extracts Author/Year from document content (NOT from metadata — documents table lacks it)
- Malformed table output returns error message string (user re-clicks Lit Review to retry)
- Lit Review button visible in document notebook preset panel with table-cells icon
- Click triggers LLM call and renders GFM table in chat with Bootstrap styling
- AI-generated content disclaimer appears on lit review output
- Table wrapped in .lit-review-scroll div with horizontal scroll and frozen first column
- Dark theme CSS variants handle bslib dark mode
- Cost logged under "lit_review_table" category
- Warning toast shown at 20+ papers
</success_criteria>

<output>
After completion, create `.planning/phases/28-literature-review-table/28-01-SUMMARY.md`
</output>
