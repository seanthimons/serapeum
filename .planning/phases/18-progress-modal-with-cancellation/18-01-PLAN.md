---
phase: 18-progress-modal-with-cancellation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - R/interrupt.R
  - R/citation_network.R
  - R/mod_citation_network.R
autonomous: true

must_haves:
  truths:
    - "interrupt flag file can be created, checked, signalled, and cleaned up across processes"
    - "fetch_citation_network returns partial results with partial=TRUE when interrupted"
    - "ExtendedTask invokes fetch_citation_network in mirai with interrupt_flag passed through"
  artifacts:
    - path: "R/interrupt.R"
      provides: "File-based interrupt flag utilities for cross-process cancellation"
      exports: ["create_interrupt_flag", "check_interrupt", "signal_interrupt", "clear_interrupt_flag", "cleanup_session_flags"]
    - path: "R/citation_network.R"
      provides: "fetch_citation_network with interrupt_flag parameter and partial result return"
      contains: "interrupt_flag"
    - path: "R/mod_citation_network.R"
      provides: "ExtendedTask definition and async invoke replacing withProgress"
      contains: "ExtendedTask"
  key_links:
    - from: "R/citation_network.R"
      to: "R/interrupt.R"
      via: "check_interrupt() called at each BFS hop and each frontier paper"
      pattern: "check_interrupt"
    - from: "R/mod_citation_network.R"
      to: "R/citation_network.R"
      via: "ExtendedTask invokes fetch_citation_network with interrupt_flag argument"
      pattern: "fetch_citation_network.*interrupt_flag"
    - from: "R/mod_citation_network.R"
      to: "R/interrupt.R"
      via: "create_interrupt_flag() called before invoke, flag path passed to mirai"
      pattern: "create_interrupt_flag"
---

<objective>
Create interrupt utilities, add interrupt support to fetch_citation_network, and replace synchronous withProgress build with ExtendedTask + mirai async invocation.

Purpose: This plan establishes the async infrastructure. The interrupt flag enables cross-process cancellation (mirai runs in a separate R process). The ExtendedTask replaces the blocking withProgress call so the Shiny UI stays responsive during builds.

Output: R/interrupt.R with 5 utility functions, fetch_citation_network with interrupt_flag support and partial returns, and mod_citation_network.R refactored to use ExtendedTask + mirai with a basic modal placeholder.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-progress-modal-with-cancellation/18-RESEARCH.md
@R/citation_network.R
@R/mod_citation_network.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create interrupt utilities and add interrupt support to fetch_citation_network</name>
  <files>R/interrupt.R, R/citation_network.R</files>
  <action>
**1. Create R/interrupt.R** with file-based interrupt flag utilities that work across process boundaries (mirai runs in separate R process):

- `create_interrupt_flag(session_id)`: Creates a temp file named `serapeum_interrupt_{session_id}_{random}.flag` with content "running". Returns path. Use `tempfile()` with pattern and `.flag` extension.
- `check_interrupt(flag_file)`: Returns TRUE if file content is "interrupt". Wrap `readLines()` in `tryCatch` returning "running" on error. Return FALSE if flag_file is NULL or file doesn't exist.
- `signal_interrupt(flag_file)`: Writes "interrupt" to the flag file. Wrap in `tryCatch` to silently handle errors (file deleted, etc.).
- `clear_interrupt_flag(flag_file)`: Calls `unlink()` on the file if it exists. Null-safe.
- `cleanup_session_flags(session_id)`: Globs `tempdir()` for pattern `serapeum_interrupt_{session_id}_*.flag` and unlinks all. Returns count of cleaned files invisibly.

**2. Modify fetch_citation_network() in R/citation_network.R:**

- Add `interrupt_flag = NULL` parameter (after `progress_callback`).
- At the START of each BFS hop (inside `for (hop in seq_len(depth))`), before fetching any papers, check: `if (!is.null(interrupt_flag) && check_interrupt(interrupt_flag))`. When interrupt detected:
  - Call `progress_callback("Cancelled by user", 1.0)` if callback exists.
  - Convert accumulated `nodes_list` and `edges_list` to data frames using the same `do.call(rbind, lapply(...))` pattern already at the bottom of the function.
  - For empty lists, return the same empty data frame structure as the seed-not-found case.
  - Return `list(nodes = nodes_df, edges = edges_df, partial = TRUE)`.
- Also check interrupt INSIDE the inner `for (frontier_paper in current_frontier)` loop, at the start of each iteration. This provides finer-grained cancellation within a hop (a single hop can process 100 frontier papers). Same partial return pattern.
- Modify the final return to include `partial = FALSE`: change `list(nodes = nodes_df, edges = edges_df)` to `list(nodes = nodes_df, edges = edges_df, partial = FALSE)`.

Note: Do NOT change the function signature's existing parameters or their defaults. Only ADD interrupt_flag. The existing progress_callback pattern remains unchanged.
  </action>
  <verify>
Run in R to confirm: `source("R/interrupt.R"); flag <- create_interrupt_flag("test"); cat("exists:", file.exists(flag), "\n"); cat("not interrupted:", !check_interrupt(flag), "\n"); signal_interrupt(flag); cat("interrupted:", check_interrupt(flag), "\n"); clear_interrupt_flag(flag); cat("cleaned:", !file.exists(flag), "\n")`

Then verify fetch_citation_network signature: `source("R/citation_network.R"); cat("interrupt_flag param:", "interrupt_flag" %in% names(formals(fetch_citation_network)), "\n")`
  </verify>
  <done>
- R/interrupt.R exists with all 5 functions exported
- fetch_citation_network accepts interrupt_flag parameter
- Interrupt check occurs at start of each BFS hop AND each frontier paper iteration
- Partial results returned with partial=TRUE flag when interrupted
- Full results returned with partial=FALSE flag on normal completion
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace withProgress with ExtendedTask + mirai async invocation</name>
  <files>R/mod_citation_network.R</files>
  <action>
Refactor mod_citation_network_server to use ExtendedTask + mirai for non-blocking builds. This task sets up the async infrastructure and a basic modal. Plan 02 will add the polished progress UI, cancel handler, and result handler.

**Key constraint:** mirai executes in an ISOLATED R process. It cannot access Shiny session, reactives, or sourced functions. All needed functions and data must be passed as arguments or sourced inside the mirai block.

**A. Add reactive state** (near existing reactiveVals):
- `current_interrupt_flag <- reactiveVal(NULL)` to track the active interrupt flag file path.
- `progress_poller <- reactiveVal(NULL)` to store the polling observer reference (scoped so cancel and result handlers can both destroy it).

**B. Create ExtendedTask** (after reactiveVals, before observers):
```r
network_task <- ExtendedTask$new(function(seed_id, email, direction, depth, node_limit, interrupt_flag, app_dir) {
  mirai::mirai({
    # Source required files in isolated process
    source(file.path(app_dir, "R", "interrupt.R"), local = TRUE)
    source(file.path(app_dir, "R", "api_openalex.R"), local = TRUE)
    source(file.path(app_dir, "R", "citation_network.R"), local = TRUE)

    # Build network with interrupt support
    result <- fetch_citation_network(
      seed_id, email, api_key = NULL,
      direction = direction, depth = depth,
      node_limit = node_limit,
      progress_callback = NULL,
      interrupt_flag = interrupt_flag
    )

    # Compute layout for full results only
    if (!isTRUE(result$partial) && nrow(result$nodes) > 0) {
      result$nodes <- compute_layout_positions(result$nodes, result$edges)
    }

    result
  }, seed_id = seed_id, email = email, direction = direction,
     depth = depth, node_limit = node_limit,
     interrupt_flag = interrupt_flag, app_dir = app_dir)
})
```
Pass `app_dir = getwd()` so mirai can source files. The mirai block sources `interrupt.R`, `api_openalex.R`, and `citation_network.R` inside the isolated process.

Note: `progress_callback` is NULL inside mirai because we cannot send messages back to the Shiny session from a mirai process. Progress is handled via polling on the main session side (added in plan 02).

**C. Replace the build_network observeEvent** (the `withProgress` block):

Remove the entire `withProgress` block. Replace with:

1. Create interrupt flag: `flag_file <- create_interrupt_flag(session$token); current_interrupt_flag(flag_file)`
2. Show a basic modal: `showModal(modalDialog(title = "Building Citation Network", "Building network... please wait.", footer = NULL, easyClose = FALSE, size = "m"))` (plan 02 will enhance this with progress bar, status text, and Stop button)
3. Invoke task: `network_task$invoke(seed_id = current_seed_id(), email = config_r()$openalex$email, direction = input$direction, depth = input$depth, node_limit = input$node_limit, interrupt_flag = flag_file, app_dir = getwd())`

**D. Add basic task result handler** using `observe()` on `network_task$result()`:
```r
observe({
  result <- network_task$result()
  req(result)

  # Close modal
  removeModal()

  # Clean up interrupt flag
  flag_file <- current_interrupt_flag()
  clear_interrupt_flag(flag_file)
  current_interrupt_flag(NULL)

  # Handle empty results
  if (is.null(result$nodes) || nrow(result$nodes) == 0) {
    showNotification("No papers found in citation network", type = "warning")
    return()
  }

  # Compute layout for partial results (skipped in mirai for partials)
  if (isTRUE(result$partial)) {
    result$nodes <- compute_layout_positions(result$nodes, result$edges)
  }

  # Build visualization data — reuse exact same pattern as current code
  palette <- input$palette %||% "viridis"
  seed_id <- current_seed_id()
  viz_data <- build_network_data(result$nodes, result$edges, palette, seed_id)

  # Store network — same pattern as current code
  net_list <- list(
    nodes = viz_data$nodes,
    edges = viz_data$edges,
    metadata = list(
      seed_paper_id = seed_id,
      seed_paper_title = viz_data$nodes$paper_title[viz_data$nodes$is_seed][1],
      direction = input$direction,
      depth = input$depth,
      node_limit = input$node_limit,
      palette = palette,
      partial = isTRUE(result$partial)
    )
  )
  current_network_data(net_list)
  unfiltered_network_data(net_list)

  # Notification
  showNotification(
    sprintf("Network built: %d nodes, %d edges", nrow(viz_data$nodes), nrow(viz_data$edges)),
    type = "message"
  )
})
```

**E. Remove old build_in_progress reactiveVal and output$build_progress renderUI** since the modal replaces the inline spinner. Also remove the `build_in_progress(TRUE)` / `on.exit(build_in_progress(FALSE))` calls. Remove `uiOutput(ns("build_progress"))` from the UI function controls bar.

**F. Add session cleanup** at the end of moduleServer:
```r
session$onSessionEnded(function() {
  cleanup_session_flags(session$token)
})
```

Keep all other existing functionality (save network, load network, palette change, year filter, node click, side panel) completely unchanged.

**CRITICAL — Interrupt flag flow verification:**
The interrupt_flag flows through 3 files and must be verified end-to-end:
1. `mod_citation_network.R` calls `create_interrupt_flag(session$token)` -> gets `flag_file` path
2. `flag_file` is passed to `network_task$invoke(... interrupt_flag = flag_file ...)`
3. Inside `ExtendedTask$new`, `interrupt_flag` is passed as a mirai argument
4. Inside the `mirai({...})` block, `interrupt_flag` is passed to `fetch_citation_network(... interrupt_flag = interrupt_flag ...)`
5. Inside `fetch_citation_network`, `check_interrupt(interrupt_flag)` reads the flag file at each BFS hop
6. Back in `mod_citation_network.R`, `signal_interrupt(flag_file)` writes "interrupt" to the same file (added in plan 02 cancel handler)

This chain works because the flag is a FILE PATH (string), which serializes across process boundaries. The mirai process and Shiny process share the same filesystem.
  </action>
  <verify>
1. Verify the interrupt_flag flow explicitly:
   - Search R/mod_citation_network.R for `create_interrupt_flag` (must exist)
   - Search R/mod_citation_network.R for `interrupt_flag = flag_file` in the invoke call (must exist)
   - Search R/mod_citation_network.R for `interrupt_flag = interrupt_flag` in the mirai block (must exist)
   - Search R/mod_citation_network.R for `fetch_citation_network.*interrupt_flag` in the mirai block (must exist)
2. Verify ExtendedTask is used: search for "ExtendedTask" in R/mod_citation_network.R.
3. Verify withProgress is removed: search for "withProgress" in R/mod_citation_network.R (should return no results).
4. Start the app: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "shiny::runApp('.', port = 3838, launch.browser = FALSE)"` and confirm no startup errors.
  </verify>
  <done>
- Build button launches async ExtendedTask via mirai (UI stays responsive)
- Basic modal appears during build (placeholder for plan 02 enhancements)
- Completed builds close modal and display network
- withProgress() usage fully removed
- Interrupt flag created before invoke and passed through mirai to fetch_citation_network
- Session cleanup removes orphaned interrupt flag files
  </done>
</task>

</tasks>

<verification>
- `R/interrupt.R` exists with create/check/signal/clear/cleanup functions
- `fetch_citation_network()` accepts `interrupt_flag` parameter and returns `partial` flag
- `mod_citation_network.R` uses ExtendedTask + mirai (no withProgress)
- Basic modal shows during builds
- Interrupt flag flows: create -> invoke -> mirai -> fetch_citation_network -> check_interrupt
- App starts without errors
</verification>

<success_criteria>
1. Interrupt flag utilities work correctly (create, check, signal, clear, cleanup)
2. fetch_citation_network returns partial=TRUE when interrupted, partial=FALSE on completion
3. Build button triggers async ExtendedTask via mirai (no UI blocking)
4. Completed builds display network with notification
5. No withProgress() usage remains
6. Interrupt flag path flows end-to-end from create through mirai to fetch_citation_network
</success_criteria>

<output>
After completion, create `.planning/phases/18-progress-modal-with-cancellation/18-01-SUMMARY.md`
</output>
