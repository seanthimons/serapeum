---
phase: 18-progress-modal-with-cancellation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - R/interrupt.R
  - R/citation_network.R
  - R/mod_citation_network.R
autonomous: false

must_haves:
  truths:
    - "User sees progress modal with live status during citation network build"
    - "User can click Stop button to cancel citation network build mid-operation"
    - "Cancelled builds display accumulated nodes collected before cancellation"
    - "Progress modal shows granular status updates (hop N of M, papers found)"
  artifacts:
    - path: "R/interrupt.R"
      provides: "File-based interrupt flag utilities for cross-process cancellation"
      exports: ["create_interrupt_flag", "check_interrupt", "signal_interrupt", "clear_interrupt_flag", "cleanup_session_flags"]
    - path: "R/citation_network.R"
      provides: "fetch_citation_network with interrupt_flag parameter and partial result return"
      contains: "interrupt_flag"
    - path: "R/mod_citation_network.R"
      provides: "ExtendedTask-based async build with progress modal and cancel button"
      contains: "ExtendedTask"
  key_links:
    - from: "R/mod_citation_network.R"
      to: "R/interrupt.R"
      via: "create_interrupt_flag() and signal_interrupt() calls"
      pattern: "create_interrupt_flag|signal_interrupt"
    - from: "R/citation_network.R"
      to: "R/interrupt.R"
      via: "check_interrupt() called at each BFS hop"
      pattern: "check_interrupt"
    - from: "R/mod_citation_network.R"
      to: "R/citation_network.R"
      via: "ExtendedTask invokes fetch_citation_network with interrupt_flag"
      pattern: "network_task.*invoke|fetch_citation_network.*interrupt_flag"
    - from: "R/mod_citation_network.R cancel button"
      to: "R/mod_citation_network.R task"
      via: "signal_interrupt() then network_task$cancel()"
      pattern: "cancel_build|signal_interrupt"
---

<objective>
Add async progress modal with cancellation to citation network builds using ExtendedTask + mirai.

Purpose: Long-running citation network operations (depth 2-3, up to 200 nodes) currently block the Shiny UI with a basic withProgress bar. Users cannot cancel, and all progress is lost if something goes wrong. This plan replaces the synchronous build with a non-blocking async operation, custom progress modal with a Stop button, and graceful cancellation that returns partial results.

Output: Users see a modal with progress bar and status text during builds, can click Stop to cancel and keep accumulated nodes, and the UI remains responsive throughout.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-progress-modal-with-cancellation/18-RESEARCH.md
@R/citation_network.R
@R/mod_citation_network.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create interrupt utilities and add interrupt support to fetch_citation_network</name>
  <files>R/interrupt.R, R/citation_network.R</files>
  <action>
**1. Create R/interrupt.R** with file-based interrupt flag utilities that work across process boundaries (mirai runs in separate R process):

- `create_interrupt_flag(session_id)`: Creates a temp file named `serapeum_interrupt_{session_id}_{random}.flag` with content "running". Returns path. Use `tempfile()` with pattern and `.flag` extension.
- `check_interrupt(flag_file)`: Returns TRUE if file content is "interrupt". Wrap `readLines()` in `tryCatch` returning "running" on error. Return FALSE if flag_file is NULL or file doesn't exist.
- `signal_interrupt(flag_file)`: Writes "interrupt" to the flag file. Wrap in `tryCatch` to silently handle errors (file deleted, etc.).
- `clear_interrupt_flag(flag_file)`: Calls `unlink()` on the file if it exists. Null-safe.
- `cleanup_session_flags(session_id)`: Globs `tempdir()` for pattern `serapeum_interrupt_{session_id}_*.flag` and unlinks all. Returns count of cleaned files invisibly.

**2. Modify fetch_citation_network() in R/citation_network.R:**

- Add `interrupt_flag = NULL` parameter (after `progress_callback`).
- At the START of each BFS hop (inside `for (hop in seq_len(depth))`), before fetching any papers, check: `if (!is.null(interrupt_flag) && check_interrupt(interrupt_flag))`. When interrupt detected:
  - Call `progress_callback("Cancelled by user", 1.0)` if callback exists.
  - Convert accumulated `nodes_list` and `edges_list` to data frames using the same `do.call(rbind, lapply(...))` pattern already at the bottom of the function.
  - For empty lists, return the same empty data frame structure as the seed-not-found case.
  - Return `list(nodes = nodes_df, edges = edges_df, partial = TRUE)`.
- Also check interrupt INSIDE the inner `for (frontier_paper in current_frontier)` loop, at the start of each iteration. This provides finer-grained cancellation within a hop (a single hop can process 100 frontier papers). Same partial return pattern.
- Modify the final return to include `partial = FALSE`: change `list(nodes = nodes_df, edges = edges_df)` to `list(nodes = nodes_df, edges = edges_df, partial = FALSE)`.

Note: Do NOT change the function signature's existing parameters or their defaults. Only ADD interrupt_flag. The existing progress_callback pattern remains unchanged.
  </action>
  <verify>
Run in R to confirm: `source("R/interrupt.R"); flag <- create_interrupt_flag("test"); cat("exists:", file.exists(flag), "\n"); cat("not interrupted:", !check_interrupt(flag), "\n"); signal_interrupt(flag); cat("interrupted:", check_interrupt(flag), "\n"); clear_interrupt_flag(flag); cat("cleaned:", !file.exists(flag), "\n")`

Then verify fetch_citation_network signature: `source("R/citation_network.R"); cat("interrupt_flag param:", "interrupt_flag" %in% names(formals(fetch_citation_network)), "\n")`
  </verify>
  <done>
- R/interrupt.R exists with all 5 functions exported
- fetch_citation_network accepts interrupt_flag parameter
- Interrupt check occurs at start of each BFS hop AND each frontier paper iteration
- Partial results returned with partial=TRUE flag when interrupted
- Full results returned with partial=FALSE flag on normal completion
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace synchronous build with ExtendedTask async, progress modal, and cancel button</name>
  <files>R/mod_citation_network.R</files>
  <action>
Refactor the citation network module server to use ExtendedTask + mirai for non-blocking builds with a custom progress modal and cancel handler.

**Key constraint:** mirai executes in an ISOLATED R process. It cannot access Shiny session, reactives, or sourced functions. All needed functions and data must be passed as arguments or sourced inside the mirai block.

**Changes to mod_citation_network_server:**

**A. Add reactive state** (near existing reactiveVals):
- `current_interrupt_flag <- reactiveVal(NULL)` to track the active interrupt flag file path.

**B. Create ExtendedTask** (after reactiveVals, before observers):
```r
network_task <- ExtendedTask$new(function(seed_id, email, direction, depth, node_limit, interrupt_flag, app_dir) {
  mirai::mirai({
    # Source required files in isolated process
    source(file.path(app_dir, "R", "interrupt.R"), local = TRUE)
    source(file.path(app_dir, "R", "api_openalex.R"), local = TRUE)
    source(file.path(app_dir, "R", "citation_network.R"), local = TRUE)

    # Build network with interrupt support
    result <- fetch_citation_network(
      seed_id, email, api_key = NULL,
      direction = direction, depth = depth,
      node_limit = node_limit,
      progress_callback = NULL,
      interrupt_flag = interrupt_flag
    )

    # Compute layout for full results only
    if (!isTRUE(result$partial) && nrow(result$nodes) > 0) {
      result$nodes <- compute_layout_positions(result$nodes, result$edges)
    }

    result
  }, seed_id = seed_id, email = email, direction = direction,
     depth = depth, node_limit = node_limit,
     interrupt_flag = interrupt_flag, app_dir = app_dir)
})
```
Pass `app_dir = getwd()` (or use `.app_dir` if the app sets one) so mirai can source files. The mirai block sources `interrupt.R`, `api_openalex.R`, and `citation_network.R` inside the isolated process.

Note: `progress_callback` is NULL inside mirai because we cannot send messages back to the Shiny session from a mirai process. Progress is handled via polling on the main session side.

**C. Replace the build_network observeEvent** (lines ~317-388 in current file):

Remove the entire `withProgress` block. Replace with:

1. Create interrupt flag: `flag_file <- create_interrupt_flag(session$token); current_interrupt_flag(flag_file)`
2. Show custom progress modal using `showModal(modalDialog(...))`:
   - Title: spinner icon + "Building Citation Network"
   - Bootstrap progress bar (striped, animated) with id `ns("build_progress_bar")`, starting at 5%
   - Status message div with id `ns("build_progress_message")`, text "Initializing..."
   - Footer: single `actionButton(ns("cancel_build"), "Stop", class = "btn-warning", icon = icon("stop"))`
   - `easyClose = FALSE` (prevent accidental dismissal)
   - `size = "m"`
3. Invoke task: `network_task$invoke(seed_id = current_seed_id(), email = config_r()$openalex$email, direction = input$direction, depth = input$depth, node_limit = input$node_limit, interrupt_flag = flag_file, app_dir = getwd())`
4. Start a polling observer for simulated progress (since mirai can't push progress back):
   ```r
   poll_count <- reactiveVal(0L)
   progress_poller <- observe({
     invalidateLater(2000)  # every 2 seconds
     n <- isolate(poll_count()) + 1L
     poll_count(n)
     # Increment progress bar smoothly: 5% -> ~85% over time
     pct <- min(5 + n * 8, 85)
     session$sendCustomMessage("updateBuildProgress", list(
       bar_id = ns("build_progress_bar"),
       msg_id = ns("build_progress_message"),
       percent = pct,
       message = paste0("Fetching citations (step ", n, ")...")
     ))
   })
   ```
   Store the observer reference so it can be destroyed later.

**D. Register JavaScript handler ONCE** in the UI function (not in modal show):

Add to `mod_citation_network_ui`, inside the existing `tagList`, a `tags$script(HTML(...))` block:
```javascript
Shiny.addCustomMessageHandler('updateBuildProgress', function(data) {
  var bar = document.getElementById(data.bar_id);
  if (bar) {
    bar.style.width = data.percent + '%';
    bar.textContent = data.percent + '%';
    bar.setAttribute('aria-valuenow', data.percent);
  }
  var msg = document.getElementById(data.msg_id);
  if (msg) {
    msg.textContent = data.message;
  }
});
```

This is registered once, not per-modal-show, avoiding the memory leak pitfall from research.

**E. Cancel button handler:**
```r
observeEvent(input$cancel_build, {
  # Signal interrupt to the running mirai process
  flag_file <- current_interrupt_flag()
  if (!is.null(flag_file)) {
    signal_interrupt(flag_file)
  }

  # Cancel the ExtendedTask
  network_task$cancel()

  # Stop progress poller
  if (exists("progress_poller") && !is.null(progress_poller)) {
    progress_poller$destroy()
  }

  # Close modal immediately (don't wait for task return)
  removeModal()

  # Clean up flag
  clear_interrupt_flag(flag_file)
  current_interrupt_flag(NULL)

  showNotification(
    "Network build stopped. Partial results will display if available.",
    type = "warning", duration = 5
  )
})
```

**F. Task result handler** using `observe()` on `network_task$result()`:
```r
observe({
  result <- network_task$result()
  req(result)

  # Stop progress poller
  if (exists("progress_poller") && !is.null(progress_poller)) {
    progress_poller$destroy()
  }

  # Close modal
  removeModal()

  # Clean up interrupt flag
  flag_file <- current_interrupt_flag()
  clear_interrupt_flag(flag_file)
  current_interrupt_flag(NULL)

  # Handle empty results
  if (is.null(result$nodes) || nrow(result$nodes) == 0) {
    showNotification("No papers found in citation network", type = "warning")
    return()
  }

  # Compute layout for partial results (skipped in mirai for partials)
  if (isTRUE(result$partial)) {
    result$nodes <- compute_layout_positions(result$nodes, result$edges)
  }

  # Build visualization data
  palette <- input$palette %||% "viridis"
  seed_id <- current_seed_id()
  viz_data <- build_network_data(result$nodes, result$edges, palette, seed_id)

  # Store network
  net_list <- list(
    nodes = viz_data$nodes,
    edges = viz_data$edges,
    metadata = list(
      seed_paper_id = seed_id,
      seed_paper_title = viz_data$nodes$paper_title[viz_data$nodes$is_seed][1],
      direction = input$direction,
      depth = input$depth,
      node_limit = input$node_limit,
      palette = palette,
      partial = isTRUE(result$partial)
    )
  )
  current_network_data(net_list)
  unfiltered_network_data(net_list)

  # Notification
  if (isTRUE(result$partial)) {
    showNotification(
      sprintf("Partial network: %d nodes, %d edges (stopped by user)",
              nrow(viz_data$nodes), nrow(viz_data$edges)),
      type = "message", duration = 8
    )
  } else {
    showNotification(
      sprintf("Network built: %d nodes, %d edges",
              nrow(viz_data$nodes), nrow(viz_data$edges)),
      type = "message"
    )
  }
})
```

**G. Session cleanup:**
Add at the end of moduleServer:
```r
session$onSessionEnded(function() {
  cleanup_session_flags(session$token)
})
```

**H. Remove old build_in_progress reactiveVal and output$build_progress renderUI** since the modal replaces the inline spinner. Also remove the `build_in_progress(TRUE)` / `on.exit(build_in_progress(FALSE))` calls.

**Important implementation notes:**
- The `progress_poller` observer variable must be scoped so both the cancel handler and result handler can destroy it. Use a `reactiveVal` or environment variable within the moduleServer scope.
- `build_in_progress` reactiveVal and its `output$build_progress` renderUI can be removed since the modal now serves as the progress indicator.
- The `uiOutput(ns("build_progress"))` in the UI function can be removed from the controls bar.
- Keep all other existing functionality (save network, load network, palette change, year filter, node click, side panel) completely unchanged.
  </action>
  <verify>
1. Start the app: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "shiny::runApp('.', port = 3838, launch.browser = FALSE)"` and confirm no startup errors.
2. Check that the module loads without errors by navigating to the citation network tab.
3. Verify ExtendedTask is used: search for "ExtendedTask" in R/mod_citation_network.R.
4. Verify withProgress is removed: search for "withProgress" in R/mod_citation_network.R (should return no results).
5. Verify JavaScript handler registered: search for "updateBuildProgress" in R/mod_citation_network.R.
  </verify>
  <done>
- Build button launches async ExtendedTask via mirai (UI stays responsive)
- Custom modal appears with animated progress bar and Stop button
- Stop button signals interrupt, cancels task, closes modal immediately
- Completed builds close modal and display full network
- Cancelled builds display partial network with notification
- Session cleanup removes orphaned interrupt flag files
- No withProgress() usage remains
- JavaScript handler registered once (no memory leak)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Async citation network build with progress modal, cancel button, and partial results</what-built>
  <how-to-verify>
1. Open the app at http://localhost:3838
2. Navigate to Citation Network tab
3. Select any seed paper and click "Build Network" with depth=2, node_limit=100
4. **Progress modal test:** Verify a modal appears with:
   - Spinner icon and "Building Citation Network" title
   - Animated progress bar that increments
   - Status text updating (e.g., "Fetching citations (step 1)...")
   - A yellow "Stop" button in the footer
   - Modal cannot be dismissed by clicking outside
5. **Full build test:** Let the build complete. Modal should close, network should display, notification should say "Network built: X nodes, Y edges"
6. **Cancel test:** Start another build (depth=2 or depth=3 for longer operation). Click "Stop" partway through.
   - Modal should close immediately
   - Notification should say "Partial network" or "stopped by user"
   - If partial nodes were collected, a partial network should display
7. **UI responsiveness test:** During a build, try interacting with other UI elements. The app should remain responsive (not frozen).
8. **Subsequent build test:** After a cancel, start a new build. It should work normally without leftover state.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
- `R/interrupt.R` exists with create/check/signal/clear/cleanup functions
- `fetch_citation_network()` accepts `interrupt_flag` parameter and returns `partial` flag
- `mod_citation_network.R` uses ExtendedTask + mirai (no withProgress)
- Custom progress modal shows during builds with Stop button
- Cancel triggers interrupt flag + task cancellation
- Partial results displayed when cancelled
- Session cleanup prevents flag file accumulation
- App starts without errors
</verification>

<success_criteria>
1. User sees progress modal with animated bar and status text during citation network build
2. User can click Stop to cancel build; modal closes immediately
3. Cancelled builds display partial results (accumulated nodes before cancellation)
4. Progress modal shows updating status messages
5. App UI remains responsive during async build
6. No leaked observers, flag files, or mirai processes after cancel or completion
</success_criteria>

<output>
After completion, create `.planning/phases/18-progress-modal-with-cancellation/18-01-SUMMARY.md`
</output>
