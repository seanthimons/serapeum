---
phase: 03-topic-explorer
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - R/mod_topic_explorer.R
  - app.R
autonomous: false

must_haves:
  truths:
    - "User can browse OpenAlex topics in a 4-level hierarchy (domain > field > subfield > topic)"
    - "Selecting a topic shows papers filtered by that topic in a search notebook"
    - "Topic data is cached locally in DuckDB so browsing works without repeated API calls"
    - "Topic search/filter is available to narrow the hierarchy when browsing"
  artifacts:
    - path: "R/mod_topic_explorer.R"
      provides: "Topic explorer Shiny module with cascading selects and search"
      exports: ["mod_topic_explorer_ui", "mod_topic_explorer_server"]
      min_lines: 120
    - path: "app.R"
      provides: "Sidebar button, view routing, and producer-consumer wiring for topic explorer"
      contains: "mod_topic_explorer"
  key_links:
    - from: "R/mod_topic_explorer.R"
      to: "R/db.R"
      via: "get_cached_topics, cache_topics, get_hierarchy_choices"
      pattern: "get_cached_topics|cache_topics|get_hierarchy_choices"
    - from: "R/mod_topic_explorer.R"
      to: "R/api_openalex.R"
      via: "fetch_all_topics when cache is empty/stale"
      pattern: "fetch_all_topics"
    - from: "app.R"
      to: "R/mod_topic_explorer.R"
      via: "producer-consumer pattern (topic_request reactive)"
      pattern: "mod_topic_explorer_server.*topic_request"
    - from: "app.R"
      to: "OpenAlex works API"
      via: "build_openalex_request with primary_topic.id filter"
      pattern: "primary_topic\\.id"
---

<objective>
Create the topic explorer Shiny module and wire it into the main app using the producer-consumer pattern.

Purpose: Delivers the user-facing feature -- a hierarchical topic browser with search that lets users select a research topic and create a filtered search notebook. This is the third discovery mode alongside seed paper and query builder.

Output: New module file R/mod_topic_explorer.R and updated app.R with sidebar button, view routing, and consumer logic.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-topic-explorer/03-RESEARCH.md
@.planning/phases/03-topic-explorer/03-01-SUMMARY.md
@R/mod_seed_discovery.R
@R/mod_query_builder.R
@app.R
@R/api_openalex.R
@R/db.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create topic explorer module</name>
  <files>R/mod_topic_explorer.R</files>
  <action>
Create R/mod_topic_explorer.R following the exact pattern of mod_seed_discovery.R and mod_query_builder.R.

**UI function** `mod_topic_explorer_ui(id)`:
- Use `card()` with `card_header("Explore Topics")` and `card_body()`
- Cache status indicator: `uiOutput(ns("cache_status"))` at top showing topic count and last refresh date
- A "Refresh Topics" link button below cache status for manual cache refresh
- `hr()` separator
- Topic search box: `textInput(ns("topic_search"), "Search topics:", placeholder = "Type to filter topics...")` -- this satisfies the "topic search/filter" success criterion
- Four cascading selectInput widgets with proper ns() namespacing:
  - `selectInput(ns("domain"), "1. Domain", choices = c("Loading..." = ""))`
  - `selectInput(ns("field"), "2. Field", choices = c("Select domain first" = ""))`
  - `selectInput(ns("subfield"), "3. Subfield", choices = c("Select field first" = ""))`
  - `selectInput(ns("topic"), "4. Topic", choices = c("Select subfield first" = ""))`
- Topic details panel: `uiOutput(ns("topic_details"))` showing name, description, works_count when a topic is selected
- `hr()` separator
- Create notebook button: `actionButton(ns("create_notebook_btn"), "Explore This Topic", class = "btn-success w-100", icon = icon("book"))` -- disabled by default

**Server function** `mod_topic_explorer_server(id, con, config)`:
- Parameters match existing modules: `con` is reactive DB connection, `config` is reactive config
- Internal reactiveVals: `topics_cache` (data.frame), `topic_request` (NULL)

**Cache loading** (observe, bindEvent(TRUE, once = TRUE)):
- Call `get_cached_topics(con(), max_age_days = 30)`
- If cache empty (nrow == 0), fetch from API:
  - Get email and api_key from config via `get_setting(cfg, "openalex", "email")` and `get_setting(cfg, "openalex", "api_key")`
  - Validate api_key present, show notification error if missing directing to Settings
  - Wrap in `withProgress(message = "Fetching topic taxonomy from OpenAlex...", { })`
  - Call `fetch_all_topics(email, api_key)` in tryCatch, show error notification on failure
  - On success, call `cache_topics(con(), topics_df)` and set `topics_cache(topics_df)`
- If cache fresh, set `topics_cache(cached)`

**Cache status output** (`output$cache_status`):
- If topics_cache() has rows: show "N topics cached (last updated: DATE)" with the count and date from quality_cache_meta
- If empty: show "No topics cached yet"

**Refresh button** (observeEvent on ns("refresh_topics")):
- Refetch topics from API regardless of cache age
- Same logic as initial fetch but forced

**Topic search filtering**:
- When `input$topic_search` changes (debounce 300ms via `debounce(reactive(input$topic_search), 300)`):
  - If search text is empty, show normal domain choices from `get_hierarchy_choices(con(), "domain")`
  - If search text has 2+ characters, query DuckDB directly: `SELECT DISTINCT topic_id, display_name, works_count, domain_name, field_name, subfield_name FROM topics WHERE LOWER(display_name) LIKE ? OR LOWER(description) LIKE ? ORDER BY works_count DESC LIMIT 50` with `paste0("%", tolower(search_text), "%")`
  - Update the topic selectInput directly with matching results (bypass hierarchy), formatted as "TopicName -- Domain > Field > Subfield (N works)"
  - Clear domain/field/subfield selects when search is active
  - When search cleared, restore normal hierarchy cascade

**Hierarchy cascade** (four observe blocks, each with bindEvent):
- Domain selected -> update field choices via `get_hierarchy_choices(con(), "field", input$domain)`, reset subfield and topic to empty placeholder
- Field selected -> update subfield choices, reset topic to empty
- Subfield selected -> update topic choices
- Topic selected -> show details panel

IMPORTANT cascade reset: When a parent changes, explicitly clear ALL downstream selects using `updateSelectInput(session, "field", choices = c("Select field..." = ""), selected = "")` etc. This prevents stale selections from a previous hierarchy path.

**Topic details** (`output$topic_details`):
- When topic selected, query full topic row from DB
- Show in a `div(class = "border rounded p-3 bg-light mt-3")`: topic display_name as h5, description as small text-muted paragraph, works_count formatted with commas, keywords parsed from JSON and shown as badges

**Create notebook button** (observeEvent):
- Require input$topic is non-empty
- Query topic row from DB for display_name
- Set `topic_request()` to list with: topic_id, topic_name, notebook_name = paste("Topic:", display_name)
- This is the producer output

**Return value**: Return `topic_request` reactive (matches mod_seed_discovery.R and mod_query_builder.R pattern)

Use consistent code style: roxygen comments, ns() for all input/output IDs, `%||%` for defaults, `req()` for guards.
  </action>
  <verify>
Source file without errors:
```
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "library(shiny); library(bslib); source('R/mod_topic_explorer.R'); cat('UI exists:', exists('mod_topic_explorer_ui'), '\n'); cat('Server exists:', exists('mod_topic_explorer_server'), '\n')"
```
Both functions should exist.
  </verify>
  <done>
  - Module has 4 cascading selectInputs for domain > field > subfield > topic hierarchy
  - Topic search box filters topics across the hierarchy by name/description using SQL LIKE
  - Cache is loaded on module init, fetched from API if stale/missing
  - Topic details (name, description, works count, keywords) shown on selection
  - Create notebook button produces topic_request reactive for app.R consumption
  - Cascade resets downstream selects when parent changes
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire topic explorer into app.R</name>
  <files>app.R</files>
  <action>
Modify app.R in three locations, following the exact patterns used for seed discovery and query builder:

**1. Sidebar button (UI section, around line 49-50, after the "Build a Query" button):**
Add a new button in the existing `div(class = "d-grid gap-2 mb-3")`:
```r
actionButton("explore_topics", "Explore Topics",
             class = "btn-outline-warning",
             icon = icon("compass"))
```
Place it after the "Build a Query" button. Use btn-outline-warning to visually distinguish from existing buttons.

**2. View routing (server section):**

Add click handler for the new sidebar button (near line 242, after the build_query handler):
```r
observeEvent(input$explore_topics, {
  current_notebook(NULL)
  current_view("topic_explorer")
})
```

Add view rendering in the `output$main_content` renderUI block (near line 457, after the query_builder view check):
```r
if (view == "topic_explorer") {
  return(mod_topic_explorer_ui("topic_explorer"))
}
```

**3. Module server + consumer (server section, near line 546, after query_request):**

Initialize module server:
```r
# Topic explorer module
topic_request <- mod_topic_explorer_server("topic_explorer", reactive(con), config_file_r)
```

Add consumer observeEvent (follows the query_request consumer pattern from lines 620-711):
```r
observeEvent(topic_request(), {
  req <- topic_request()
  if (is.null(req)) return()

  # Create notebook with topic filter
  filter_str <- paste0("primary_topic.id:", req$topic_id)

  filters <- list(
    filter = filter_str,
    topic_id = req$topic_id,
    topic_name = req$topic_name
  )

  nb_id <- create_notebook(con, req$notebook_name, "search",
                           search_query = "",
                           search_filters = filters)

  # Fetch papers filtered by topic
  email <- get_setting(config_file, "openalex", "email")
  api_key <- get_setting(config_file, "openalex", "api_key")

  withProgress(message = paste("Searching papers for topic:", req$topic_name), {
    results <- tryCatch({
      req_obj <- build_openalex_request("works", email, api_key) |>
        req_url_query(filter = filter_str, per_page = 50)

      resp <- req_perform(req_obj)
      body <- resp_body_json(resp)

      if (is.null(body$results)) list()
      else lapply(body$results, parse_openalex_work)
    }, error = function(e) {
      showNotification(paste("Search error:", e$message), type = "error")
      list()
    })

    if (length(results) > 0) {
      for (paper in results) {
        existing <- dbGetQuery(con, "SELECT id FROM abstracts WHERE notebook_id = ? AND paper_id = ?",
                               list(nb_id, paper$paper_id))
        if (nrow(existing) > 0) next

        abstract_id <- create_abstract(
          con, nb_id, paper$paper_id, paper$title,
          paper$authors, paper$abstract,
          paper$year, paper$venue, paper$pdf_url,
          keywords = paper$keywords,
          work_type = paper$work_type,
          work_type_crossref = paper$work_type_crossref,
          oa_status = paper$oa_status,
          is_oa = paper$is_oa,
          cited_by_count = paper$cited_by_count,
          referenced_works_count = paper$referenced_works_count,
          fwci = paper$fwci
        )

        if (!is.na(paper$abstract) && nchar(paper$abstract) > 0) {
          create_chunk(con, abstract_id, "abstract", 0, paper$abstract)
        }
      }
    }

    incProgress(1.0)
  })

  # Navigate to new notebook
  notebook_refresh(notebook_refresh() + 1)
  current_notebook(nb_id)
  current_view("notebook")
  showNotification(paste("Created notebook with", length(results), "papers for topic:", req$topic_name), type = "message")
})
```

This consumer follows the EXACT same pattern as the query_builder consumer (lines 620-711): create notebook, fetch papers via OpenAlex, insert as abstracts, navigate to notebook.

IMPORTANT: The `results` variable must be accessible in the showNotification call. Declare it with `results <- list()` before the withProgress block if scoping is an issue, or keep the notification inside the withProgress block.
  </action>
  <verify>
Start the Shiny app and verify:
```
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "shiny::runApp('app.R', port = 8080, launch.browser = FALSE)"
```
App should start without errors. Check for the "Explore Topics" button in the sidebar.
  </verify>
  <done>
  - "Explore Topics" button appears in sidebar alongside existing discovery buttons
  - Clicking the button shows the topic explorer module UI
  - Selecting a topic and clicking "Explore This Topic" creates a search notebook filtered by primary_topic.id
  - Papers are fetched from OpenAlex and populated in the notebook
  - Navigation switches to the new notebook after creation
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete topic explorer flow</name>
  <action>Human verification of the complete topic explorer feature end-to-end.</action>
  <what-built>Complete topic explorer feature: hierarchical browsing UI with 4-level cascade (domain > field > subfield > topic), topic search, local DuckDB caching, and notebook creation via producer-consumer pattern.</what-built>
  <how-to-verify>
    1. Start the app: open http://localhost:8080
    2. Click "Explore Topics" in the sidebar -- should show the topic explorer UI
    3. If first time: should show progress indicator while fetching ~4,500 topics from OpenAlex (requires API key in Settings)
    4. Select a Domain from the dropdown -- Field dropdown should populate
    5. Select a Field -- Subfield dropdown should populate
    6. Select a Subfield -- Topic dropdown should populate with "(N works)" counts
    7. Select a Topic -- details panel should show name, description, works count
    8. Try the search box: type a topic name (e.g., "machine learning") -- should filter topics across hierarchy
    9. Click "Explore This Topic" -- should create a new search notebook with papers
    10. Verify the notebook contains papers filtered by the selected topic
    11. Change Domain selection -- verify Field/Subfield/Topic all reset properly
    12. Close and reopen app -- topics should load from cache (no API fetch needed)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. R/mod_topic_explorer.R exists with mod_topic_explorer_ui() and mod_topic_explorer_server()
2. app.R has "Explore Topics" sidebar button, view routing, and topic_request consumer
3. Topic hierarchy browsing works: domain -> field -> subfield -> topic
4. Topic search filters topics by name/description
5. Creating notebook fetches papers filtered by primary_topic.id from OpenAlex
6. Cache persists across sessions (topics table in DuckDB, freshness in quality_cache_meta)
</verification>

<success_criteria>
- User can browse 4-level topic hierarchy via cascading dropdowns
- User can search/filter topics by name
- Selecting a topic and clicking create produces a search notebook with papers for that topic
- Topics cached in DuckDB, not re-fetched on every app start (30-day TTL)
- All 4 roadmap success criteria for Phase 3 are met
</success_criteria>

<output>
After completion, create `.planning/phases/03-topic-explorer/03-02-SUMMARY.md`
</output>
