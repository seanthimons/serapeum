---
phase: 09-bug-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - R/api_openalex.R
  - R/api_openrouter.R
  - R/mod_search_notebook.R
  - R/mod_topic_explorer.R
  - app.R
autonomous: true
must_haves:
  truths:
    - "User can browse OpenAlex topics without encountering 401 authentication errors"
    - "User sees plain-language error messages with expandable details when API calls fail"
    - "Error severity is visually distinguished: red for hard failures, yellow for warnings"
    - "User can switch between search notebook and other tabs without triggering duplicate OpenAlex requests"
    - "Cached search results persist and display immediately when returning to search notebook"
  artifacts:
    - path: "R/api_openalex.R"
      provides: "Fixed OpenAlex auth (no Bearer header) + error classification + custom condition throwing"
      contains: "req_url_query.*api_key"
    - path: "R/api_openrouter.R"
      provides: "Custom condition throwing for OpenRouter API errors"
      contains: "stop_api_error"
    - path: "R/mod_search_notebook.R"
      provides: "Toast notifications for search errors + no duplicate requests on tab return"
      contains: "show_error_toast"
    - path: "R/mod_topic_explorer.R"
      provides: "Friendly error toast for topic fetch failures"
      contains: "show_error_toast"
  key_links:
    - from: "R/api_openalex.R"
      to: "OpenAlex API"
      via: "req_url_query for api_key instead of Bearer header"
      pattern: "req_url_query.*api_key"
    - from: "R/api_openalex.R"
      to: "R/mod_search_notebook.R"
      via: "Custom condition with classified error data (message, details, severity) thrown once in API layer, caught in UI layer"
      pattern: "stop_api_error|api_error"
    - from: "R/mod_search_notebook.R"
      to: "UI toast notifications"
      via: "showNotification with severity styling, extracting pre-classified data from condition"
      pattern: "show_error_toast"
---

<objective>
Fix three API interaction bugs: OpenAlex 401 errors on topic browsing, raw HTTP error codes shown to users, and duplicate OpenAlex requests on tab navigation.

Purpose: Make API interactions reliable and user-friendly — researchers should never see raw HTTP codes or encounter preventable errors.
Output: Patched API clients and modules with proper auth, friendly errors, and no duplicate requests.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-bug-fixes/09-CONTEXT.md
@R/api_openalex.R
@R/api_openrouter.R
@R/mod_search_notebook.R
@R/mod_topic_explorer.R
@app.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix OpenAlex 401 auth and create error classification + custom condition helper</name>
  <files>R/api_openalex.R, R/api_openrouter.R</files>
  <action>
**BUGF-01 Root cause:** `build_openalex_request()` (line 18-20) sends `Authorization: Bearer {api_key}` header. OpenAlex does NOT use Bearer token auth — it expects the API key as a query parameter. Sending an Authorization header causes 401 Unauthorized responses.

Fix `build_openalex_request()`:
- Remove the `req_headers("Authorization" = ...)` block (lines 18-20)
- Instead, when `api_key` is non-null and non-empty, add it as a query parameter: `req |> req_url_query(api_key = api_key)`
- Keep the `mailto` email parameter as-is (that part is correct)

**Error classification helper and custom condition thrower (for BUGF-02):**
Add two helper functions at the top of `R/api_openalex.R` (they will be sourced and available globally since all R/*.R files are sourced at app startup — this is standard R/Shiny behavior):

```r
#' Classify an API error into user-friendly message with details
#' @param e Error object or condition
#' @param service Service name ("OpenAlex" or "OpenRouter")
#' @return list(message, details, severity) where severity is "error" or "warning"
classify_api_error <- function(e, service = "API") {
  msg <- conditionMessage(e)

  # Extract HTTP status code if present (httr2 pattern)
  status <- NULL
  if (grepl("HTTP (\\d{3})", msg)) {
    status <- as.integer(regmatches(msg, regexpr("\\d{3}", msg)))
  }

  # Classify by status code
  if (!is.null(status)) {
    result <- switch(as.character(status),
      "401" = list(
        message = paste(service, "authentication failed. Check your API key in Settings."),
        severity = "error"
      ),
      "403" = list(
        message = paste(service, "access denied. Your API key may lack required permissions."),
        severity = "error"
      ),
      "404" = list(
        message = paste(service, "resource not found. The requested endpoint may have changed."),
        severity = "error"
      ),
      "429" = list(
        message = paste(service, "rate limit reached. Please wait a moment and try again."),
        severity = "warning"
      ),
      "500" = list(
        message = paste(service, "is experiencing issues. Please try again later."),
        severity = "error"
      ),
      "502" = ,
      "503" = ,
      "504" = list(
        message = paste(service, "is temporarily unavailable. Please try again in a few minutes."),
        severity = "warning"
      ),
      # Default for other status codes
      list(
        message = paste(service, "request failed. Please try again."),
        severity = "error"
      )
    )
  } else if (grepl("timed? ?out|timeout", msg, ignore.case = TRUE)) {
    result <- list(
      message = paste(service, "request timed out. The service may be slow — try again."),
      severity = "warning"
    )
  } else if (grepl("could not resolve|connection refused|no internet", msg, ignore.case = TRUE)) {
    result <- list(
      message = paste("Cannot reach", service, ". Check your internet connection."),
      severity = "error"
    )
  } else {
    result <- list(
      message = paste(service, "request failed unexpectedly."),
      severity = "error"
    )
  }

  result$details <- msg
  result
}

#' Classify and throw an API error as a custom condition
#' The condition carries message, details, and severity so callers
#' can extract all three without re-classifying.
#' @param e Original error/condition
#' @param service Service name ("OpenAlex" or "OpenRouter")
stop_api_error <- function(e, service = "API") {
  err <- classify_api_error(e, service)
  cond <- structure(
    class = c("api_error", "error", "condition"),
    list(
      message = err$message,
      details = err$details,
      severity = err$severity
    )
  )
  stop(cond)
}
```

**IMPORTANT — Single-classification data flow:** API files classify ONCE via `stop_api_error()`, which throws a custom `api_error` condition carrying `message`, `details`, and `severity`. UI modules catch this condition and extract all three fields directly — they do NOT call `classify_api_error()` again. This avoids the double-classification anti-pattern where the re-thrown message would lose details/severity.

**Update error handling in `R/api_openalex.R`:**
- In `search_papers()` (line 251-255): Replace `stop("OpenAlex API error: ", e$message)` with:
  ```r
  resp <- tryCatch({
    req_perform(req)
  }, error = function(e) {
    stop_api_error(e, "OpenAlex")
  })
  ```
- In `fetch_all_topics()` (line 621-625): Same pattern — replace with `stop_api_error(e, "OpenAlex")`.
- In `get_paper()`, `get_citing_papers()`, `get_cited_papers()`, `get_related_papers()`: These already return NULL on error which is fine, but update their `message()` calls to use `classify_api_error()` for consistent logging.

**Update error handling in `R/api_openrouter.R`:**
- In `chat_completion()` (line 45-49): Replace `stop("OpenRouter API error: ", e$message)` with `stop_api_error(e, "OpenRouter")`.
- In `get_embeddings()` (line 78-82): Same pattern.
- Do NOT touch `list_models()`, `list_embedding_models()`, `list_chat_models()`, `get_openrouter_credits()` — these already have graceful fallbacks returning defaults/NULL.
  </action>
  <verify>
  1. Read `R/api_openalex.R` and confirm `build_openalex_request()` no longer has Bearer auth header, and uses `req_url_query(api_key = api_key)` instead.
  2. Confirm `classify_api_error()` function exists and handles status codes 401, 403, 404, 429, 500, 502-504, timeout, and connection errors.
  3. Confirm `stop_api_error()` function exists and creates a custom condition with class `c("api_error", "error", "condition")` carrying `message`, `details`, and `severity`.
  4. Confirm `search_papers()`, `fetch_all_topics()`, `chat_completion()`, `get_embeddings()` all use `stop_api_error()` (NOT `stop(err$message)`).
  5. Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "source('R/api_openalex.R'); source('R/api_openrouter.R'); cat('Sourced OK\n')"` — no syntax errors.
  </verify>
  <done>
  - `build_openalex_request()` sends api_key as query param, not Bearer header
  - `classify_api_error()` exists and returns {message, details, severity} for all common HTTP error patterns
  - `stop_api_error()` exists and throws a custom `api_error` condition with all three fields attached
  - All main API functions use `stop_api_error()` to throw rich conditions instead of plain `stop()` with just a message string
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply friendly toast notifications across all API call sites</name>
  <files>R/mod_search_notebook.R, R/mod_topic_explorer.R, app.R</files>
  <action>
**Per user decision:** Toast notifications (non-blocking), plain language up front with expandable "Show details" toggle, no action buttons (no Retry), severity-based styling (red/danger for hard failures, yellow/warning for degraded results).

**Note on function availability:** All files in `R/` are sourced globally at app startup. Functions defined in any `R/*.R` file (like `classify_api_error`, `stop_api_error`, `show_error_toast`) are available to all other files. This is standard R/Shiny behavior — no imports needed.

**Create a toast helper** at the top of `R/mod_search_notebook.R` (will be available globally):

```r
#' Show a user-friendly error toast notification
#' @param message Plain language error message
#' @param details Technical details (HTTP status, raw error)
#' @param severity "error" or "warning"
#' @param duration Auto-dismiss seconds (default 8 for errors, 5 for warnings)
show_error_toast <- function(message, details = NULL, severity = "error", duration = NULL) {
  if (is.null(duration)) {
    duration <- if (severity == "warning") 5 else 8
  }

  # Build notification content with optional expandable details
  content <- if (!is.null(details) && nchar(details) > 0) {
    HTML(paste0(
      '<div>', htmltools::htmlEscape(message), '</div>',
      '<details class="mt-1"><summary class="small text-muted" style="cursor:pointer;">Show details</summary>',
      '<div class="small text-muted mt-1 font-monospace" style="word-break:break-all;">',
      htmltools::htmlEscape(details),
      '</div></details>'
    ))
  } else {
    message
  }

  type <- if (severity == "warning") "warning" else "error"
  showNotification(content, type = type, duration = duration)
}
```

**IMPORTANT — Extract from condition, do NOT re-classify:** Since Task 1 has API files throw custom `api_error` conditions via `stop_api_error()`, the UI layer catches these conditions and extracts the pre-classified data directly. The pattern at every catch site is:

```r
tryCatch({
  # ... API call ...
}, error = function(e) {
  # Extract pre-classified data from the custom condition.
  # If it's an api_error condition (from stop_api_error), fields are attached directly.
  # If it's some other error (not from our API layer), fall back to classify_api_error.
  if (inherits(e, "api_error")) {
    show_error_toast(e$message, e$details, e$severity)
  } else {
    err <- classify_api_error(e, "Service")
    show_error_toast(err$message, err$details, err$severity)
  }
})
```

This ensures error classification happens exactly ONCE — in the API layer via `stop_api_error()`. The UI layer just reads the already-classified fields. The `else` branch is a safety net for unexpected non-API errors.

**Update `R/mod_search_notebook.R`:**
- Search refresh error handler (around line 1288-1291): Replace `showNotification(paste("Search error:", e$message), type = "error", duration = 10)` with:
  ```r
  if (inherits(e, "api_error")) {
    show_error_toast(e$message, e$details, e$severity)
  } else {
    err <- classify_api_error(e, "OpenAlex")
    show_error_toast(err$message, err$details, err$severity)
  }
  ```
- Embedding error in the embed handler (line 1460): The per-chunk error is logged via `message()` which is fine (internal). But if ALL chunks fail, add a toast. No change needed since individual chunk errors are silent and the overall flow continues.
- Chat error handler (line 1640-1644): The `rag_query` call catches errors and returns string. Update to use condition extraction:
  ```r
  response <- tryCatch({
    rag_query(con(), cfg, user_msg, nb_id, use_ragnar = TRUE, session_id = session$token)
  }, error = function(e) {
    if (inherits(e, "api_error")) {
      show_error_toast(e$message, e$details, e$severity)
    } else {
      err <- classify_api_error(e, "OpenRouter")
      show_error_toast(err$message, err$details, err$severity)
    }
    paste("Sorry, I encountered an error processing your question.")
  })
  ```

**Update `R/mod_topic_explorer.R`:**
- Cache loading error (line 92-97): Replace `showNotification(paste("Error fetching topics:", e$message), ...)` with:
  ```r
  if (inherits(e, "api_error")) {
    show_error_toast(e$message, e$details, e$severity)
  } else {
    err <- classify_api_error(e, "OpenAlex")
    show_error_toast(err$message, err$details, err$severity)
  }
  ```
- Refresh button error (line 148-153): Same replacement.

**Update `app.R`:**
- Topic request error handler (around line 885-887): Replace `showNotification(paste("Search error:", e$message), type = "error")` with condition-aware toast (same pattern as above, service = "OpenAlex").
- Discovery request error handlers: Check if there are tryCatch blocks for `get_citing_papers`, `get_cited_papers`, `get_related_papers` calls. These are in the `withProgress` block (lines 712-717) but don't have explicit error handling — the functions themselves return NULL/empty on error. Add a tryCatch around the switch statement:
  ```r
  papers <- tryCatch({
    switch(req$citation_type, ...)
  }, error = function(e) {
    if (inherits(e, "api_error")) {
      show_error_toast(e$message, e$details, e$severity)
    } else {
      err <- classify_api_error(e, "OpenAlex")
      show_error_toast(err$message, err$details, err$severity)
    }
    list()
  })
  ```
  </action>
  <verify>
  1. Search for all `showNotification.*error` calls in the modified files — each should use `show_error_toast()` for API-related errors (non-API errors like "Search query cannot be empty" should keep simple `showNotification`).
  2. Confirm `show_error_toast()` function exists with `message`, `details`, `severity` params.
  3. Confirm NO catch site calls `classify_api_error()` as the primary path — it should only appear in the `else` fallback branch for non-api_error conditions. The primary path must use `inherits(e, "api_error")` and extract `e$message`, `e$details`, `e$severity` directly.
  4. Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "library(shiny); library(htmltools); for(f in list.files('R', pattern='\\.R$', full.names=TRUE)) source(f); cat('All sourced OK\n')"` — no syntax errors.
  </verify>
  <done>
  - All API error call sites show toast with plain language message and expandable technical details
  - Error classification happens exactly ONCE in the API layer (via stop_api_error); UI layer extracts pre-classified data from the custom condition
  - Red/danger styling for hard failures (401, 403, 500), yellow/warning for rate limits and timeouts
  - No "Retry" buttons — user retries by repeating their action
  - Non-API validation errors (empty query, missing key) keep their simple showNotification style
  </done>
</task>

<task type="auto">
  <name>Task 3: Prevent duplicate OpenAlex requests on tab navigation</name>
  <files>R/mod_search_notebook.R</files>
  <action>
**Root cause analysis:** In `app.R`, `output$main_content` is a `renderUI` that re-creates the module UI (`mod_search_notebook_ui("search_notebook")`) every time `current_view()` changes. The module server (`mod_search_notebook_server`) is called once at app init (line 678), so it persists. However, when the UI is re-created, Shiny re-initializes input bindings. The `observeEvent(list(input$refresh_search, search_refresh_trigger()), ignoreInit = TRUE, ...)` at line 1249 should not fire on UI re-creation because `ignoreInit = TRUE` skips the first evaluation. But in practice, Shiny may re-fire the `observeEvent` when the UI reconnects because the input value transitions from NULL (disconnected) to 0 (new button), which `observeEvent` may treat as a change.

**Per user decision:** Cached results shown as-is when returning — no new API call. Results persist until user explicitly runs a new search. No visual indicator for cached results.

**Fix approach (PREFERRED):** Split the combined `observeEvent` into two separate observers that share a common refresh function. This isolates each trigger so UI re-rendering cannot cause spurious fires.

In `mod_search_notebook_server`, extract the refresh logic into a local function and split the observer:

```r
# Extract refresh logic into a local function
do_search_refresh <- function() {
  nb_id <- notebook_id()
  req(nb_id)
  # ... all existing code from the observeEvent body ...
}

# Explicit refresh button - use ignoreInit = TRUE and also ignoreNULL = TRUE
observeEvent(input$refresh_search, {
  do_search_refresh()
}, ignoreInit = TRUE, ignoreNULL = TRUE)

# Programmatic refresh (from save_search)
observeEvent(search_refresh_trigger(), {
  do_search_refresh()
}, ignoreInit = TRUE)
```

By splitting into two separate `observeEvent` blocks:
- `input$refresh_search` with `ignoreInit = TRUE` only fires on actual button clicks
- `search_refresh_trigger()` only fires when explicitly incremented by save_search
- Neither fires on UI re-creation because `ignoreInit = TRUE` skips the initial evaluation, and Shiny treats the UI reconnection as a new init for each separate observer

The key insight: `list()` combined listeners are more prone to firing on UI re-render because ANY element changing triggers the combined observer. Splitting them isolates each trigger.

Move the entire body of the current `observeEvent(list(input$refresh_search, search_refresh_trigger()), ...)` (lines 1249-1363) into a local function `do_search_refresh`, then create the two separate observers that call it.
  </action>
  <verify>
  1. Confirm the combined `observeEvent(list(input$refresh_search, search_refresh_trigger()), ...)` no longer exists.
  2. Confirm two separate `observeEvent` blocks exist: one for `input$refresh_search`, one for `search_refresh_trigger()`, both with `ignoreInit = TRUE`.
  3. Confirm both call the same `do_search_refresh()` local function.
  4. Run: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "library(shiny); library(bslib); library(DBI); library(duckdb); library(httr2); library(jsonlite); library(htmltools); for(f in list.files('R', pattern='\\.R$', full.names=TRUE)) source(f); cat('All sourced OK\n')"` — no syntax errors.
  </verify>
  <done>
  - Search refresh only fires on explicit user action (button click or save-and-refresh)
  - Navigating away and returning to search notebook shows cached DB results without API call
  - Results persist until user explicitly clicks Refresh or saves edited search
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Source all R files without errors
2. Confirm `build_openalex_request()` uses query param auth, not Bearer header
3. Confirm `classify_api_error()`, `stop_api_error()`, and `show_error_toast()` exist
4. Confirm error data flows ONCE: API layer classifies via `stop_api_error()` -> custom condition -> UI layer extracts `e$message`, `e$details`, `e$severity` directly
5. Confirm no combined `observeEvent(list(input$refresh_search, ...))` pattern remains
6. Run tests: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_dir('tests/testthat')"`
</verification>

<success_criteria>
- OpenAlex API requests authenticate via query param, not Bearer header (fixes 401)
- All API error sites show friendly toast with expandable details
- Error classification happens exactly once (in API layer), not twice
- Tab navigation does not retrigger OpenAlex search requests
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-bug-fixes/09-01-SUMMARY.md`
</output>
